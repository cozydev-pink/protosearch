[{"fileName":"quickstart.md","title":"quickstart","anchor":null,"body":"Quick Start"},{"fileName":"quickstart.md","title":"Dependencies","anchor":"dependencies","body":"http4s is available for Scala 2.12, 2.13, and 3.2+. You can add http4s to your build by adding its modules to libraryDependencies in your build.sbt.\nval http4sVersion = \"@VERSION@\"\n\nlibraryDependencies ++= Seq(\n  \"org.http4s\" %% \"http4s-ember-client\" % http4sVersion,\n  \"org.http4s\" %% \"http4s-ember-server\" % http4sVersion,\n  \"org.http4s\" %% \"http4s-dsl\"          % http4sVersion,\n)\nThis brings in the Ember HTTP client and server implementation as well as the routing DSL. This is most likely what you want. Other integration modules are available as well, such as for working with JSON, or using alternative client/server implementations, such as Netty. Note that these integration modules are generally versioned separately from http4s core; check their documentation for compatibility information.\nDepending on your usecase, you may want to consider one of several other http4s modules. For example, if you are writing a library, you probably want to develop it against the generic http4s interfaces, without hard-coding a particular implementation, such as Ember.\nlibraryDependencies ++= Seq(\n  \"org.http4s\" %% \"http4s-core\"         % http4sVersion,\n  \"org.http4s\" %% \"http4s-client\"       % http4sVersion,\n  \"org.http4s\" %% \"http4s-server\"       % http4sVersion,\n)\nTo run with 2.12 please make sure that the flag -Ypartial-unification\nis enabled in your compiler options (i.e scalacOptions += \"-Ypartial-unification\" in sbt).\nThis feature is enabled by default starting in Scala 2.13."},{"fileName":"quickstart.md","title":"Giter8 Template","anchor":"giter8-template","body":"Getting started with http4s is easy.  Let's materialize an http4s\nskeleton project from its giter8 template:\n# for Scala 2.x\n$ sbt new http4s/http4s.g8 --branch 0.23\n\n# for Scala 3\n$ sbt new http4s/http4s.g8 --branch 0.23-scala3\nFollow the prompts.  For every step along the way, a default value is\nprovided in brackets.\nname\n: name of your project.\norganization\n: the organization you publish under.  It's common practice on the JVM\nto make this a domain you own, in reverse order (i.e., TLD first).\nio.github.username is also a fine choice.\npackage\n: by default, your organization followed by the project name.\nsbt_version\n: the version of SBT for your generated project.\nscala_version\n: the version of Scala for your generated project.\nhttp4s_version\n: defaults to the latest stable release of http4s.  See\n  the versions page for other suggestions.\nlogback_version\n: the version of Logback for logging in your generated project.\nAt the end of the process, you'll see:\nTemplate applied in ./quickstart\nIn addition to sbt build machinery, some Scala source files are\ngenerated:\n$ cd quickstart\n$ find src/main -name '*.scala'\n./src/main/scala/com/example/quickstart/HelloWorld.scala\n./src/main/scala/com/example/quickstart/QuickstartRoutes.scala\n./src/main/scala/com/example/quickstart/Jokes.scala\n./src/main/scala/com/example/quickstart/Main.scala\n./src/main/scala/com/example/quickstart/QuickstartServer.scala\nMain.scala defines a runnable object Main extends IOApp with an entry point method run\nwhich calls the stream method of the object QuickstartServer defined on QuickstartServer.scala.\nStarting ember, http4s' native server backend.\nQuickStartRoutes has two route definitions. The helloWorldRoutes containing a simple HttpRoutes\nthat responds to GET/hello/$USERNAME with a JSON greeting.  Let's try it:\n$ sbt run\nDepending on the state of your Ivy cache, several dependencies will\ndownload.  This is a good time to grab a beverage.  When you come\nback, you should see a line similar to this:\n[io-compute-1] INFO  o.h.e.s.EmberServerBuilderCompanionPlatform - Ember-Server service bound to address: [::]:8080\nThis indicates that ember is running our service on port 8080. Let's try out the\nhello world service with curl:\n$ curl -i http://localhost:8080/hello/world\nHTTP/1.1 200 OK\nContent-Type: application/json\nDate: Sun, 28 Jun 2020 16:23:31 GMT\nContent-Length: 26\n\n{\"message\":\"Hello, world\"}\nTo shut down your server, simply press ^C in your console. Note that\nwhen running interactive SBT, ^C will kill the SBT process. For rapid\napplication development, you may wish to add the sbt-revolver plugin\nto your project and starting the server from the SBT prompt with reStart.\nWith just a few commands, we have a fully functional app for creating\na simple JSON service."},{"fileName":"integrations.md","title":"integrations","anchor":null,"body":"Integrations\nHttp4s provides a standard interface for defining services and clients. This enables an ecosystem of interchangeable server and client backends.\nThere are also integrations for entities, metrics, and more. Check out the \"Related Projects\" section of the navigation menu for the complete list of integrations."},{"fileName":"integrations.md","title":"Ember","anchor":"ember","body":"Http4s Ember is a server and client backend developed in the core repository.\nImplements HTTP/1 and HTTP/2Runs on JDK 8+, Node.js 16+, and Scala NativePure FP, built with Cats Effect and FS2\nlibraryDependencies ++= Seq(\n  \"org.http4s\" %% \"http4s-ember-server\" % \"@VERSION@\",\n  \"org.http4s\" %% \"http4s-ember-client\" % \"@VERSION@\",\n)"},{"fileName":"integrations.md","title":"Backend Integrations","anchor":"backend-integrations","body":"Table\n  BackendPlatformHttp ClientHttp ServerWebsocket ClientWebsocket ServerProxy support (Client)\n  EmberJDK 8+ / Node.js 16+ / Native✅✅❌✅❌BlazeJDK 8+✅✅❌✅❌NettyJDK 8+✅✅✅✅✅JDK Http ClientJDK 11+✅❌✅❌✅ServletJDK 8+❌✅❌❌❌DOMBrowsers✅❌✅❌❌FeralServerless❌✅❌❌❌\n  \n  "},{"fileName":"integrations.md","title":"Entity Integrations","anchor":"entity-integrations","body":"Http4s has multiple smaller modules for Entity encoding and decoding support of common types.\nCirceScalatagsScala XMLfs2-data"},{"fileName":"upgrading.md","title":"upgrading","anchor":null,"body":"Upgrading"},{"fileName":"upgrading.md","title":"Automated Upgrading with Scalafix","anchor":"automated-upgrading-with-scalafix","body":"http4s-0.22 comes with a scalafix that does some of the migration automatically.\nBefore you upgrade manually, we recommend you run this scalafix.\nAdd the scalafix plugin to your project/plugins.sbt or to your global plugins.addSbtPlugin(\"ch.epfl.scala\" % \"sbt-scalafix\" % \"0.9.28\")\nRun$ sbt \";scalafixEnable; scalafix github:http4s/http4s/v0_22?sha=series/0.22\"\nThe compiler errors should help you in showing what's left to upgrade.\nFor further information about the changes since 0.21, check the changelog"},{"fileName":"upgrading.md","title":"Http4s 0.21 -> 0.22 Migration Guide","anchor":"http4s-0-21-0-22-migration-guide","body":"General Changes:\nHeader names are now CIStrings which can be created by importing org.typelevel.ci._ and using the ci string interpolator.\nTable\n  0.210.22\n  headers.get(If-Match)headers.get[If-Match]Headers.of(Headers(Header(\"x-ms\", \"1\")Header(ci\"x-ms\", \"1\")baseUri +?? (\"p\", w)baseUri +?? (\"p\" -> w)\"x-ms\".cici\"x-ms\"import org.http4s.server.blazeimport org.http4s.blaze.server\n  \n  "},{"fileName":"upgrading.md","title":"Help Us Help You!","anchor":"help-us-help-you","body":"If you see recurring patterns that could benefit from a scalafix, please report them for consideration.  For general upgrade tips, please consider a pull request to this document."},{"fileName":"service.md","title":"service","anchor":null,"body":"Service\nThis tutorial will walk you through creating your first http4s service\nand calling it with http4s' client.\nCreate a new directory, with the following build.sbt in the root:\nscalaVersion := \"2.13.8\" // Also supports 2.12.x and 3.x\n\nval http4sVersion = \"@VERSION@\"\n\n// Only necessary for SNAPSHOT releases\nresolvers += Resolver.sonatypeRepo(\"snapshots\")\n\nlibraryDependencies ++= Seq(\n  \"org.http4s\" %% \"http4s-dsl\" % http4sVersion,\n  \"org.http4s\" %% \"http4s-ember-server\" % http4sVersion,\n  \"org.http4s\" %% \"http4s-ember-client\" % http4sVersion\n)\n\n// Uncomment if you're using Scala 2.12.x\n// scalacOptions ++= Seq(\"-Ypartial-unification\")\nThis tutorial is compiled as part of the build using mdoc.  Each page\nis its own REPL session.  If you copy and paste code samples starting\nfrom the top, you should be able to follow along in a REPL.\n$ sbt console"},{"fileName":"service.md","title":"Defining Your Service","anchor":"defining-your-service","body":"Wherever you are in your studies, let's create our first\nHttpRoutes.  Start by pasting these imports into your SBT console:\nimport cats.effect._, org.http4s._, org.http4s.dsl.io._\nIf you're in a REPL, we also need a runtime.  This comes for free in IOApp:\nimport cats.effect.unsafe.IORuntime\nimplicit val runtime: IORuntime = cats.effect.unsafe.IORuntime.global\nUsing the http4s-dsl, we can construct an HttpRoutes by pattern\nmatching the request.  Let's build a service that matches requests to\nGET /hello/:name, where :name is a path parameter for the person to\ngreet.\nval helloWorldService = HttpRoutes.of[IO] {\n  case GET -> Root / \"hello\" / name =>\n    Ok(s\"Hello, $name.\")\n}"},{"fileName":"service.md","title":"Returning Content in the Response","anchor":"returning-content-in-the-response","body":"In order to return content of type T in the response an EntityEncoder[T]\nmust be used. We can define the EntityEncoder[T] implictly so that it\ndoesn't need to be explicitly included when serving the response.\nIn the example below, we're defining a tweetEncoder and then\nexplicitly using it to encode the response contents of a Tweet, which can\nbe seen as Ok(getTweet(tweetId))(tweetEncoder).\nWe've defined tweetsEncoder as being implicit so that we don't need to explicitly\nreference it when serving the response, which can be seen as\ngetPopularTweets().flatMap(Ok(_)).\ncase class Tweet(id: Int, message: String)\n\nimplicit def tweetEncoder: EntityEncoder[IO, Tweet] = ???\nimplicit def tweetsEncoder: EntityEncoder[IO, Seq[Tweet]] = ???\n\ndef getTweet(tweetId: Int): IO[Tweet] = ???\ndef getPopularTweets(): IO[Seq[Tweet]] = ???\n\nval tweetService = HttpRoutes.of[IO] {\n  case GET -> Root / \"tweets\" / \"popular\" =>\n    getPopularTweets().flatMap(Ok(_))\n  case GET -> Root / \"tweets\" / IntVar(tweetId) =>\n    getTweet(tweetId).flatMap(Ok(_))\n}"},{"fileName":"service.md","title":"Running Your Service","anchor":"running-your-service","body":"http4s supports multiple server backends.  In this example, we'll use\nember, the native backend supported by http4s.\nWe start from a EmberServerBuilder, and then mount the helloWorldService under\nthe base path of / and the remainder of the services under the base\npath of /api. The services can be mounted in any order as the request will be\nmatched against the longest base paths first. The EmberServerBuilder is immutable\nwith chained methods, each returning a new builder.\nMultiple HttpRoutes can be combined with the combineK method (or its alias\n<+>) by importing cats.implicits._ and org.http4s.implicits._. Please ensure partial unification is enabled in your build.sbt.\nscalacOptions ++= Seq(\"-Ypartial-unification\")\nimport cats.syntax.all._\nimport com.comcast.ip4s._\nimport org.http4s.ember.server._\nimport org.http4s.implicits._\nimport org.http4s.server.Router\nimport scala.concurrent.duration._\nval services = tweetService <+> helloWorldService\nval httpApp = Router(\"/\" -> helloWorldService, \"/api\" -> services).orNotFound\nval server = EmberServerBuilder\n  .default[IO]\n  .withHost(ipv4\"0.0.0.0\")\n  .withPort(port\"8080\")\n  .withHttpApp(httpApp)\n  .build\nThe withHttpApp call associates the specified routes with this http server instance.\nWe start a server resource in the background.\nval shutdown = server.allocated.unsafeRunSync()._2\nUse curl, or your favorite HTTP client, to see your service in action:\n$ curl http://localhost:8080/hello/Pete"},{"fileName":"service.md","title":"Your First Service","anchor":"your-first-service","body":"An HttpRoutes[F] is a simple alias for\nKleisli[OptionT[F, *], Request, Response].  If that's meaningful to you,\ngreat.  If not, don't panic: Kleisli is just a convenient wrapper\naround a Request => F[Response], and F is an effectful\noperation.  We'll teach you what you need to know as we go, or if you\nprefer you can read these introductions first:\ncats-effect: The IO Monad for ScalaCats Kleisli Datatype\n\n\n"},{"fileName":"service.md","title":"Cleaning Up","anchor":"cleaning-up","body":"We can shut down the server by canceling its fiber.\nshutdown.unsafeRunSync()\n"},{"fileName":"dsl.md","title":"dsl","anchor":null,"body":"The http4s DSL\nRecall from earlier that an HttpRoutes[F] is just a type alias for\nKleisli[OptionT[F, *], Request[F], Response[F]].  This provides a minimal\nfoundation for declaring services and executing them on blaze or a\nservlet container.  While this foundation is composable, it is not\nhighly productive.  Most service authors will seek a higher level DSL."},{"fileName":"dsl.md","title":"Add the http4s-dsl to your build","anchor":"add-the-http4s-dsl-to-your-build","body":"One option is the http4s-dsl.  It is officially supported by the\nhttp4s team, but kept separate from core in order to encourage\nmultiple approaches for different needs.\nThis tutorial assumes that http4s-dsl is on your classpath.  Add the\nfollowing to your build.sbt:\nlibraryDependencies ++= Seq(\n  \"org.http4s\" %% \"http4s-dsl\" % http4sVersion,\n)\nAll we need is a REPL to follow along at home:\n$ sbt console"},{"fileName":"dsl.md","title":"The Simplest Service","anchor":"the-simplest-service","body":"We'll need the following imports to get started:\nimport cats.effect._\nimport cats.syntax.all._\nimport org.http4s._, org.http4s.dsl.io._, org.http4s.implicits._\nIf you're in a REPL, we also need a runtime:\nimport cats.effect.unsafe.IORuntime\nimplicit val runtime: IORuntime = cats.effect.unsafe.IORuntime.global\nThe central concept of http4s-dsl is pattern matching.  An\nHttpRoutes[F] is declared as a simple series of case statements.  Each\ncase statement attempts to match and optionally extract from an\nincoming Request[F].  The code associated with the first matching case\nis used to generate a F[Response[F]].\nThe simplest case statement matches all requests without extracting\nanything.  The right hand side of the request must return a\nF[Response[F]].\nIn the following we use cats.effect.IO as the effect type F.\nval service = HttpRoutes.of[IO] {\n  case _ =>\n    IO(Response(Status.Ok))\n}"},{"fileName":"dsl.md","title":"Testing the Service","anchor":"testing-the-service","body":"One beautiful thing about the HttpRoutes[F] model is that we don't\nneed a server to test our route.  We can construct our own request\nand experiment directly in the REPL.\nval getRoot = Request[IO](Method.GET, uri\"/\")\n\nval serviceIO = service.orNotFound.run(getRoot)\nWhere is our Response[F]?  It hasn't been created yet.  We wrapped it\nin an IO.  In a real service, generating a Response[F] is likely to\nbe an asynchronous operation with side effects, such as invoking\nanother web service or querying a database, or maybe both.  Operating\nin a F gives us control over the sequencing of operations and\nlets us reason about our code like good functional programmers.  It is\nthe HttpRoutes[F]'s job to describe the task, and the server's job to\nrun it.\nBut here in the REPL, it's up to us to run it:\nval response = serviceIO.unsafeRunSync()\nCool."},{"fileName":"dsl.md","title":"Status codes","anchor":"status-codes","body":"http4s-dsl provides a shortcut to create an F[Response] by\napplying a status code:\nval okIo: IO[Response[IO]] = Ok()\nThis simple Ok() expression succinctly says what we mean in a\nservice:\nHttpRoutes.of[IO] {\n  case _ => Ok()\n}.orNotFound.run(getRoot).unsafeRunSync()\nThis syntax works for other status codes as well.  In our example, we\ndon't return a body, so a 204 No Content would be a more appropriate\nresponse:\nHttpRoutes.of[IO] {\n  case _ => NoContent()\n}.orNotFound.run(getRoot).unsafeRunSync()"},{"fileName":"dsl.md","title":"Headers","anchor":"headers","body":"http4s adds a minimum set of headers depending on the response, e.g:\nOk(\"Ok response.\").unsafeRunSync().headers\nExtra headers can be added using putHeaders, for example to specify cache policies:\nimport org.http4s.headers.`Cache-Control`\nimport org.http4s.CacheDirective.`no-cache`\nimport cats.data.NonEmptyList\nOk(\"Ok response.\", `Cache-Control`(NonEmptyList(`no-cache`(), Nil)))\n  .unsafeRunSync().headers\nhttp4s defines all the well known headers directly, but sometimes you need to\ndefine custom headers, typically prefixed by an X-. In simple cases you can\nconstruct a Header instance by hand:\nOk(\"Ok response.\", \"X-Auth-Token\" -> \"value\")\n  .unsafeRunSync().headers"},{"fileName":"dsl.md","title":"Cookies","anchor":"cookies","body":"http4s has special support for Cookie headers using the Cookie type to add\nand invalidate cookies. Adding a cookie will generate the correct Set-Cookie header:\nOk(\"Ok response.\").map(_.addCookie(ResponseCookie(\"foo\", \"bar\")))\n  .unsafeRunSync().headers\nCookie can be further customized to set, e.g., expiration, the secure flag, httpOnly, flag, etc\nval cookieResp = {\n  for {\n    resp <- Ok(\"Ok response.\")\n    now <- HttpDate.current[IO]\n  } yield resp.addCookie(ResponseCookie(\"foo\", \"bar\",\n      expires = Some(now), httpOnly = true, secure = true))\n}\ncookieResp.unsafeRunSync().headers\nTo request a cookie to be removed on the client, you need to set the cookie value\nto empty. http4s can do that with removeCookie:\nOk(\"Ok response.\").map(_.removeCookie(\"foo\")).unsafeRunSync().headers"},{"fileName":"dsl.md","title":"Simple Bodies","anchor":"simple-bodies","body":"Most status codes take an argument as a body.  In http4s, Request[F]\nand Response[F] bodies are represented as a\nfs2.Stream[F, Byte].  It's also considered good\nHTTP manners to provide a Content-Type and, where known in advance,\nContent-Length header in one's responses.\nAll of this hassle is neatly handled by http4s' EntityEncoders.\nWe'll cover these in more depth in another tutorial.  The important point\nfor now is that a response body can be generated for any type with an\nimplicit EntityEncoder in scope.  http4s provides several out of the\nbox:\nOk(\"Received request.\").unsafeRunSync()\n\nimport java.nio.charset.StandardCharsets.UTF_8\nOk(\"binary\".getBytes(UTF_8)).unsafeRunSync()\nPer the HTTP specification, some status codes don't support a body.\nhttp4s prevents such nonsense at compile time:\nNoContent(\"does not compile\")"},{"fileName":"dsl.md","title":"Asynchronous Responses","anchor":"asynchronous-responses","body":"While http4s prefers F[_]: Async, you may be working with libraries that\nuse standard library Futures.  Some relevant imports:\nimport scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nYou can respond with a Future of any type that has an\nEntityEncoder by lifting it into IO or any F[_] that suspends future.\nNote: unlike IO, wrapping a side effect in Future does not\nsuspend it, and the resulting expression would still be side\neffectful, unless we wrap it in IO:\nIO.fromFuture ensures that the suspended future is shifted to the correct\nthread pool.\nval ioFuture = Ok(IO.fromFuture(IO(Future {\n  println(\"I run when the future is constructed.\")\n  \"Greetings from the future!\"\n})))\nioFuture.unsafeRunSync()\nAs good functional programmers who like to delay our side effects, we\nof course prefer to operate in Fs:\nval io = Ok(IO {\n  println(\"I run when the IO is run.\")\n  \"Mission accomplished!\"\n})\nio.unsafeRunSync()\nNote that in both cases, a Content-Length header is calculated.\nhttp4s waits for the Future or F to complete before wrapping it\nin its HTTP envelope, and thus has what it needs to calculate a\nContent-Length."},{"fileName":"dsl.md","title":"Streaming Bodies","anchor":"streaming-bodies","body":"Streaming bodies are supported by returning a fs2.Stream.\nLike IO, the stream may be of any type that has an\nEntityEncoder.\nAn intro to Stream is out of scope, but we can glimpse the\npower here.  This stream emits the elapsed time every 100 milliseconds\nfor one second:\nimport fs2.Stream\nimport scala.concurrent.duration._\n\nval drip: Stream[IO, String] =\n  Stream.awakeEvery[IO](100.millis).map(_.toString).take(10)\nWe can see it for ourselves in the REPL:\nval dripOutIO = drip\n  .through(fs2.text.lines)\n  .evalMap(s => { IO{println(s); s} })\n  .compile\n  .drain\ndripOutIO.unsafeRunSync()\nWhen wrapped in a Response[F], http4s will flush each chunk of a\nStream as they are emitted.  Note that a stream's length can't\ngenerally be anticipated before it runs, so this triggers chunked\ntransfer encoding:\nOk(drip)"},{"fileName":"dsl.md","title":"Responding with a Body","anchor":"responding-with-a-body","body":"\n\n"},{"fileName":"dsl.md","title":"Generating Responses","anchor":"generating-responses","body":"We'll circle back to more sophisticated pattern matching of requests,\nbut it will be a tedious affair until we learn a more succinct way of\ngenerating F[Response]s.\n\n\n\n"},{"fileName":"dsl.md","title":"Path Info","anchor":"path-info","body":"Path matching is done on the request's pathInfo.  Path info is the\nrequest's URI's path after the following:\nthe mount point of the servicethe prefix, if the service is composed with a Routerthe prefix, if the service is rewritten with TranslateUri\nMatching on request.pathInfo instead of request.uri.path allows\nmultiple services to be composed without rewriting all the path\nmatchers."},{"fileName":"dsl.md","title":"Matching Paths","anchor":"matching-paths","body":"A request to the root of the service is matched with the Root\nextractor.  Root consumes the leading slash of the path info.  The\nfollowing matches requests to GET /:\nHttpRoutes.of[IO] {\n  case GET -> Root => Ok(\"root\")\n}\nWe usually match paths in a left-associative manner with Root and\n/.  Each \"/\" after the initial slash delimits a path segment, and\nis represented in the DSL with the '/' extractor.  Segments can be\nmatched as literals or made available through standard Scala pattern\nmatching.  For example, the following service responds with \"Hello,\nAlice!\" to GET /hello/Alice:\nHttpRoutes.of[IO] {\n  case GET -> Root / \"hello\" / name => Ok(s\"Hello, ${name}!\")\n}\nThe above assumes only one path segment after \"hello\", and would not\nmatch GET /hello/Alice/Bob.  To match to an arbitrary depth, we need\na right-associative /: extractor.  In this case, there is no Root,\nand the final pattern is a Path of the remaining segments.  This would\nsay \"Hello, Alice and Bob!\"\nHttpRoutes.of[IO] {\n  case GET -> \"hello\" /: rest => Ok(s\"\"\"Hello, ${rest.segments.mkString(\" and \")}!\"\"\")\n}\nTo match a file extension on a segment, use the ~ extractor:\nHttpRoutes.of[IO] {\n  case GET -> Root / file ~ \"json\" => Ok(s\"\"\"{\"response\": \"You asked for $file\"}\"\"\")\n}"},{"fileName":"dsl.md","title":"Handling Path Parameters","anchor":"handling-path-parameters","body":"Path params can be extracted and converted to a specific type but are\nStrings by default. There are numeric extractors provided in the form\nof IntVar and LongVar, as well as UUIDVar extractor for java.util.UUID.\ndef getUserName(userId: Int): IO[String] = ???\n\nval usersService = HttpRoutes.of[IO] {\n  case GET -> Root / \"users\" / IntVar(userId) =>\n    Ok(getUserName(userId))\n}\nIf you want to extract a variable of type T, you can provide a custom extractor\nobject which implements def unapply(str: String): Option[T], similar to the way\nin which IntVar does it.\nimport java.time.LocalDate\nimport scala.util.Try\n\nobject LocalDateVar {\n  def unapply(str: String): Option[LocalDate] = {\n    if (!str.isEmpty)\n      Try(LocalDate.parse(str)).toOption\n    else\n      None\n  }\n}\n\ndef getTemperatureForecast(date: LocalDate): IO[Double] = IO(42.23)\n\nval dailyWeatherService = HttpRoutes.of[IO] {\n  case GET -> Root / \"weather\" / \"temperature\" / LocalDateVar(localDate) =>\n    Ok(getTemperatureForecast(localDate)\n      .map(s\"The temperature on $localDate will be: \" + _))\n}\n\nval request = Request[IO](Method.GET, uri\"/weather/temperature/2016-11-05\")\ndailyWeatherService.orNotFound(request).unsafeRunSync()"},{"fileName":"dsl.md","title":"Handling Matrix Path Parameters","anchor":"handling-matrix-path-parameters","body":"Matrix path parameters can be extracted using MatrixVar.\nIn following example, we extract the first and last matrix path parameters.\nBy default, matrix path parameters are extracted as Strings.\nimport org.http4s.dsl.impl.MatrixVar\n\nobject FullNameExtractor extends MatrixVar(\"name\", List(\"first\", \"last\"))\n\nval greetingService = HttpRoutes.of[IO] {\n  case GET -> Root / \"hello\" / FullNameExtractor(first, last) / \"greeting\" =>\n    Ok(s\"Hello, $first $last.\")\n}\ngreetingService\n  .orNotFound(Request[IO](\n    method = Method.GET, \n    uri = uri\"/hello/name;first=john;last=doe/greeting\"\n  )).unsafeRunSync()\nLike standard path parameters, matrix path parameters can be extracted as numeric types using IntVar or LongVar.\nobject FullNameAndIDExtractor extends MatrixVar(\"name\", List(\"first\", \"last\", \"id\"))\n\nval greetingWithIdService = HttpRoutes.of[IO] {\n  case GET -> Root / \"hello\" / FullNameAndIDExtractor(first, last, IntVar(id)) / \"greeting\" =>\n    Ok(s\"Hello, $first $last. Your User ID is $id.\")\n}\ngreetingWithIdService\n  .orNotFound(Request[IO](\n    method = Method.GET, \n    uri = uri\"/hello/name;first=john;last=doe;id=123/greeting\"\n  )).unsafeRunSync()"},{"fileName":"dsl.md","title":"Optional Query Parameters","anchor":"optional-query-parameters","body":"To accept an optional query parameter a OptionalQueryParamDecoderMatcher can be used.\nimport java.time.Year\nimplicit val yearQueryParamDecoder: QueryParamDecoder[Year] =\n  QueryParamDecoder[Int].map(Year.of)\n\nobject OptionalYearQueryParamMatcher \n  extends OptionalQueryParamDecoderMatcher[Year](\"year\")\n\ndef getAverageTemperatureForCurrentYear: IO[String] = ???\ndef getAverageTemperatureForYear(y: Year): IO[String] = ???\n\nval routes = HttpRoutes.of[IO] {\n  case GET -> Root / \"temperature\" :? OptionalYearQueryParamMatcher(maybeYear) =>\n    maybeYear match {\n      case None =>\n        Ok(getAverageTemperatureForCurrentYear)\n      case Some(year) =>\n        Ok(getAverageTemperatureForYear(year))\n    }\n}"},{"fileName":"dsl.md","title":"Missing Required Query Parameters","anchor":"missing-required-query-parameters","body":"A request with a missing required query parameter will fall through to the following case statements and may eventually return a 404. To provide contextual error handling, optional query parameters or fallback routes can be used."},{"fileName":"dsl.md","title":"Invalid Query Parameter Handling","anchor":"invalid-query-parameter-handling","body":"To validate query parsing you can use ValidatingQueryParamDecoderMatcher which returns a ParseFailure if the parameter cannot be decoded. Be careful not to return the raw invalid value in a BadRequest because it could be used for Cross Site Scripting) attacks.\nimplicit val yearQueryParamDecoder: QueryParamDecoder[Year] =\n  QueryParamDecoder[Int]\n    .emap(i => Try(Year.of(i))\n    .toEither\n    .leftMap(t => ParseFailure(t.getMessage, t.getMessage)))\n\nobject YearQueryParamMatcher extends ValidatingQueryParamDecoderMatcher[Year](\"year\")\n\nval routes = HttpRoutes.of[IO] {\n  case GET -> Root / \"temperature\" :? YearQueryParamMatcher(yearValidated) =>\n    yearValidated.fold(\n      parseFailures => BadRequest(\"unable to parse argument year\"),\n      year => Ok(getAverageTemperatureForYear(year))\n    )\n}"},{"fileName":"dsl.md","title":"Optional Invalid Query Parameter Handling","anchor":"optional-invalid-query-parameter-handling","body":"Consider OptionalValidatingQueryParamDecoderMatcher[A] given the power that\n  Option[cats.data.ValidatedNel[org.http4s.ParseFailure, A]] provides.\nobject LongParamMatcher extends OptionalValidatingQueryParamDecoderMatcher[Long](\"long\")\n\nval routes = HttpRoutes.of[IO] {\n  case GET -> Root / \"number\" :? LongParamMatcher(maybeNumber) =>\n\n    val _: Option[cats.data.ValidatedNel[org.http4s.ParseFailure, Long]] = maybeNumber\n\n    maybeNumber match {\n        case Some(n) =>\n            n.fold(\n              parseFailures => BadRequest(\"unable to parse argument 'long'\"),\n              year => Ok(n.toString)\n            )\n        case None => BadRequest(\"missing number\")\n    }\n}"},{"fileName":"dsl.md","title":"Handling Query Parameters","anchor":"handling-query-parameters","body":"A query parameter needs to have a QueryParamDecoderMatcher provided to\nextract it. In order for the QueryParamDecoderMatcher to work there needs to\nbe an implicit QueryParamDecoder[T] in scope. QueryParamDecoders for simple\ntypes can be found in the QueryParamDecoder object. There are also\nQueryParamDecoderMatchers available which can be used to\nreturn optional or validated parameter values.\nIn the example below we're finding query params named country and year and\nthen parsing them as a String and java.time.Year.\nimport java.time.Year\nobject CountryQueryParamMatcher extends QueryParamDecoderMatcher[String](\"country\")\n\nimplicit val yearQueryParamDecoder: QueryParamDecoder[Year] =\n  QueryParamDecoder[Int].map(Year.of)\n\nobject YearQueryParamMatcher extends QueryParamDecoderMatcher[Year](\"year\")\n\ndef getAverageTemperatureForCountryAndYear(country: String, year: Year): IO[Double] = ???\n\nval averageTemperatureService = HttpRoutes.of[IO] {\n  case GET -> Root / \"weather\" / \"temperature\" :? CountryQueryParamMatcher(country) +& YearQueryParamMatcher(year) =>\n    Ok(getAverageTemperatureForCountryAndYear(country, year)\n      .map(s\"Average temperature for $country in $year was: \" + _))\n}\nTo support a QueryParamDecoderMatcher[Instant], consider QueryParamCodec#instantQueryParamCodec. That\noutputs a QueryParamCodec[Instant], which offers both a QueryParamEncoder[Instant] and QueryParamDecoder[Instant].\nimport java.time.Instant\nimport java.time.format.DateTimeFormatter\n\nimplicit val isoInstantCodec: QueryParamCodec[Instant] =\n  QueryParamCodec.instantQueryParamCodec(DateTimeFormatter.ISO_INSTANT)\n\nobject IsoInstantParamMatcher extends QueryParamDecoderMatcher[Instant](\"timestamp\")\n\n\n\n"},{"fileName":"dsl.md","title":"Matching and Extracting Requests","anchor":"matching-and-extracting-requests","body":"A Request is a regular case class - you can destructure it to extract its\nvalues. By extension, you can also match/case it with different possible\ndestructurings. To build these different extractors, you can make use of the\nDSL.\n\n\n\n\n\n"},{"fileName":"middleware.md","title":"middleware","anchor":null,"body":"Middleware\nA middleware is an abstraction around a service that provides a means of manipulating\nthe Request sent to service, and/or the Response returned by the service. In\nsome cases, such as Authentication, middleware may even prevent the service\nfrom being called.\nAt its most basic, middleware is a function that takes one service\nand returns another. The middleware function can take any additional parameters \nit needs to perform its task. Let's look at a simple example.\nFor this, we'll need a dependency on the http4s dsl.\nlibraryDependencies ++= Seq(\n  \"org.http4s\" %% \"http4s-dsl\" % http4sVersion\n)\nand some imports.\nimport cats.data.Kleisli\nimport cats.effect._\nimport cats.syntax.all._\nimport org.http4s._\nimport org.http4s.dsl.io._\nimport org.http4s.implicits._\nIf you're in a REPL, we also need a runtime:\nimport cats.effect.unsafe.IORuntime\nimplicit val runtime: IORuntime = cats.effect.unsafe.IORuntime.global\nThen, we can create a middleware that adds a header to successful responses from\nthe underlying HttpRoutes like this.\ndef myMiddle(service: HttpRoutes[IO], header: Header.ToRaw): HttpRoutes[IO] = Kleisli { (req: Request[IO]) =>\n  service(req).map {\n    case Status.Successful(resp) =>\n      resp.putHeaders(header)\n    case resp => resp\n  }\n}\nAll we do here is pass the request to the service,\nwhich returns an F[Response]. So, we use map to get the request out of the task,\nadd the header if the response is a success, and then pass the response on. We could\njust as easily modify the request before we passed it to the service.\nNow, let's create a simple service. As mentioned between service and dsl, because HttpRoutes\nis implemented as a Kleisli, which is just a function at heart, we can test a\nservice without a server. Due to an HttpRoutes[F] returns a F[Response[F]],\nwe need to call unsafeRunSync on the result of the function to extract the Response[F].\nNote that basically, you shouldn't use unsafeRunSync in your application. \nHere we use it for demo reasons only.\nval service = HttpRoutes.of[IO] {\n  case GET -> Root / \"bad\" =>\n    BadRequest()\n  case _ => Ok()\n}\n\nval goodRequest = Request[IO](Method.GET, uri\"/\")\nval badRequest = Request[IO](Method.GET, uri\"/bad\")\nservice.orNotFound(goodRequest).unsafeRunSync()\nservice.orNotFound(badRequest).unsafeRunSync()\nNow, we'll apply the service to our middleware function to create a new service, and try it out.\nval modifiedService = myMiddle(service, \"SomeKey\" -> \"SomeValue\");\nmodifiedService.orNotFound(goodRequest).unsafeRunSync()\nmodifiedService.orNotFound(badRequest).unsafeRunSync()\nNote that the successful response has your header added to it.\nIf you intend to use you middleware in multiple places, you may want to implement\nit as an object and use the apply method.\nobject MyMiddle {\n  def addHeader(resp: Response[IO], header: Header.ToRaw) =\n    resp match {\n      case Status.Successful(resp) => resp.putHeaders(header)\n      case resp => resp\n    }\n\n  def apply(service: HttpRoutes[IO], header: Header.ToRaw) =\n    service.map(addHeader(_, header))\n}\n\nval newService = MyMiddle(service, \"SomeKey\" -> \"SomeValue\")\nnewService.orNotFound(goodRequest).unsafeRunSync()\nnewService.orNotFound(badRequest).unsafeRunSync()\nLet's consider Authentication middleware as an example. Authentication\nmiddleware is a function that takes AuthedRoutes[F] \n(that translates to AuthedRequest[F, T] => F[Option[Response[F]]]) \nand returns HttpRoutes[F] (that translates to Request[F] => F[Option[Response[F]]]). \nThere is a type defined for this in the http4s.server package:\ntype AuthMiddleware[F[_], T] = Middleware[OptionT[F, *], AuthedRequest[F, T], Response[F], Request[F], Response[F]]\nSee the Authentication documentation for more details."},{"fileName":"middleware.md","title":"Composing Services with Middleware","anchor":"composing-services-with-middleware","body":"Since middleware returns a Kleisli, you can compose it with another middleware.\nAdditionally, you can compose services before applying the middleware function, \nand/or compose services with the service obtained by applying some middleware function. \nFor example:\nval apiService = HttpRoutes.of[IO] {\n  case GET -> Root / \"api\" =>\n    Ok()\n}\n\nval anotherService = HttpRoutes.of[IO] {\n  case GET -> Root / \"another\" =>\n    Ok()\n}\n\nval aggregateService = apiService <+> MyMiddle(service <+> anotherService, \"SomeKey\" -> \"SomeValue\")\n\nval apiRequest = Request[IO](Method.GET, uri\"/api\")\naggregateService.orNotFound(goodRequest).unsafeRunSync()\naggregateService.orNotFound(apiRequest).unsafeRunSync()\nNote that goodRequest ran through the MyMiddle middleware and the Result had\nour header added to it. But, apiRequest did not go through the middleware and did\nnot have the header added to it's Result."},{"fileName":"middleware.md","title":"Included middleware","anchor":"included-middleware","body":"See Server Middleware."},{"fileName":"auth.md","title":"auth","anchor":null,"body":"Authentication"},{"fileName":"auth.md","title":"Built in","anchor":"built-in","body":"For this section, remember that, like mentioned in the service section, a service is a\nKleisli[OptionT[F, *], Request[F], Response[F]], the composable version of Request[F] => OptionT[F, Response[F]].\nLets start by defining all the imports we will need in the examples below:\nimport cats._, cats.effect._, cats.implicits._, cats.data._\nimport org.http4s._\nimport org.http4s.dsl.io._\nimport org.http4s.server._\nTo add authentication to a service, we need some kind of User object which identifies the user\nwho sent the request. We represent that with AuthedRequest[F, User], which allows you to reference\nsuch object, and is the equivalent to (User, Request[F]). http4s provides you with AuthedRequest,\nbut you have to provide your own user, or authInfo representation. For our purposes here we will\nuse the following definition:\ncase class User(id: Long, name: String)\nWith the request representation defined, we can move on to the AuthedRoutes[User, F], an alias for\nAuthedRequest[F, User] => OptionT[F, Response[F]]. Notice the similarity to a \"normal\" service, which\nwould be the equivalent to Request[F] => OptionT[F, Response[F]] - in other words, we are lifting the\nRequest into an AuthedRequest, and adding authentication information in the mix.\nWith that we can represent a service that requires authentication, but to actually construct it we need\nto define how to extract the authentication information from the request. For that, we need a function\nwith the following signature: Request[F] => OptionT[F, User]. Here is an example of how to define it:\nval authUser: Kleisli[OptionT[IO, *], Request[IO], User] =\n  Kleisli(_ => OptionT.liftF(IO(???)))\nIt is worth noting that we are still wrapping the user fetch in F (IO in this case), because actually\ndiscovering the user might require reading from a database or calling some other service - i.e. performing\nIO operations.\nNow we need a middleware that can bridge a \"normal\" service into an AuthedRoutes, which is quite easy to\nget using our function defined above. We use AuthMiddleware for that:\nval middleware: AuthMiddleware[IO, User] =\n  AuthMiddleware(authUser)\nFinally, we can create our AuthedRoutes, and wrap it with our authentication middleware, getting the\nfinal HttpRoutes to be exposed. Notice that we now have access to the user object in the service implementation:\nval authedRoutes: AuthedRoutes[User, IO] =\n  AuthedRoutes.of {\n    case GET -> Root / \"welcome\" as user => Ok(s\"Welcome, ${user.name}\")\n  }\n\nval service: HttpRoutes[IO] = middleware(authedRoutes)"},{"fileName":"auth.md","title":"Composing Authenticated Routes","anchor":"composing-authenticated-routes","body":"The default apply method of AuthMiddleware will consume all requests either unmatched, or\nnot authenticated by returning an empty response with status code 401 (Unauthorized). This mitigates\na kind of reconnaissance called \"spidering\", useful for white and black hat hackers to enumerate\nyour api for possible unprotected points.\nval spanishRoutes: AuthedRoutes[User, IO] =\n    AuthedRoutes.of {\n        case GET -> Root / \"hola\" as user => Ok(s\"Hola, ${user.name}\")\n    }\n\nval frenchRoutes: HttpRoutes[IO] =\n    HttpRoutes.of {\n        case GET -> Root / \"bonjour\" => Ok(s\"Bonjour\")\n    }\n\nval serviceSpanish: HttpRoutes[IO] =\n  middleware(spanishRoutes) <+> frenchRoutes\nCall to the french routes will always return 401 (Unauthorized) as they are caught by the spanish routes. To allow access to other routes you can:\nUse a Router with unique route prefixes\nval serviceRouter = {\n  Router (\n    \"/spanish\" -> middleware(spanishRoutes),\n    \"/french\" -> frenchRoutes\n  )\n}\nAllow fallthrough, using AuthMiddleware.withFallThrough.\nval middlewareWithFallThrough: AuthMiddleware[IO, User] =\n  AuthMiddleware.withFallThrough(authUser)\nval serviceSF: HttpRoutes[IO] =\n  middlewareWithFallThrough(spanishRoutes) <+> frenchRoutes\nReorder the routes so that authed routes compose last\nval serviceFS: HttpRoutes[IO] =\n  frenchRoutes <+> middlewareWithFallThrough(spanishRoutes)\nAlternatively, to customize the behavior on not authenticated if you do not\nwish to always return 401, use AuthMiddleware.noSpider and specify the onAuthFailure handler."},{"fileName":"auth.md","title":"With Kleisli","anchor":"with-kleisli","body":"To allow for failure, the authUser function has to be adjusted to a Request[F]\n=> F[Either[String,User]]. So we'll need to handle that possibility. For advanced\nerror handling, we recommend an error ADT instead of a String.\nval authUserEither: Kleisli[IO, Request[IO], Either[String,User]] =\n  Kleisli(_ => IO(???))\n\nval onFailure: AuthedRoutes[String, IO] =\n  Kleisli(req => OptionT.liftF(Forbidden(req.context)))\n\nval authMiddleware = AuthMiddleware(authUserEither, onFailure)\n\nval serviceKleisli: HttpRoutes[IO] = authMiddleware(authedRoutes)"},{"fileName":"auth.md","title":"Returning an Error Response","anchor":"returning-an-error-response","body":"Usually, it should also be possible to send back a 401 in case there was no\nvalid login. The 401 response can be adjusted as needed, some applications use a\nredirect to a login page, or a popup requesting login data. With the upcoming of\nSPA, the correct http status codes are relevant again.\n"},{"fileName":"auth.md","title":"Cookies","anchor":"cookies","body":"We'll use a small library for the signing/validation of the cookies, which\nbasically contains the code used by the Play framework for this specific task.\nlibraryDependencies += \"org.reactormonk\" %% \"cryptobits\" % \"@CRYPTOBITS_VERSION@\"\nFirst, we'll need to set the cookie. For the crypto instance, we'll need to\nprovide a private key. You usually want to set a static secret so people don't\nlose their session on server restarts, and a static secret also allows you to\nuse multiple application instances.\nThe message is simply the user id.\nimport org.reactormonk.{CryptoBits, PrivateKey}\nimport scala.io.Codec\nimport scala.util.Random\n\nval key = PrivateKey(Codec.toUTF8(Random.alphanumeric.take(20).mkString(\"\")))\nval crypto = CryptoBits(key)\nval clock = java.time.Clock.systemUTC\n\n// gotta figure out how to do the form\ndef verifyLogin(request: Request[IO]): IO[Either[String,User]] = ???\n\nval logIn: Kleisli[IO, Request[IO], Response[IO]] = Kleisli({ request =>\n  verifyLogin(request: Request[IO]).flatMap(_ match {\n    case Left(error) =>\n      Forbidden(error)\n    case Right(user) => {\n      val message = crypto.signToken(user.id.toString, clock.millis.toString)\n      Ok(\"Logged in!\").map(_.addCookie(ResponseCookie(\"authcookie\", message)))\n    }\n  })\n})\nNow that the cookie is set, we can retrieve it again in the authUser.\nimport org.http4s.headers.Cookie\n\ndef retrieveUser: Kleisli[IO, Long, User] = Kleisli(id => IO(???))\nval authUserCookie: Kleisli[IO, Request[IO], Either[String,User]] = Kleisli({ request =>\n  val message = for {\n    header  <- request.headers.get[Cookie]\n                 .toRight(\"Cookie parsing error\")\n    cookie  <- header.values.toList.find(_.name == \"authcookie\")\n                 .toRight(\"Couldn't find the authcookie\")\n    token   <- crypto.validateSignedToken(cookie.content)\n                 .toRight(\"Cookie invalid\")\n    message <- Either.catchOnly[NumberFormatException](token.toLong)\n                 .leftMap(_.toString)\n  } yield message\n  message.traverse(retrieveUser.run)\n})"},{"fileName":"auth.md","title":"Authorization Header","anchor":"authorization-header","body":"There is no inherent way to set the Authorization header, send the token in any\nway that your SPA understands. Retrieve the header value in the authUser\nfunction.\nimport org.http4s.syntax.header._\nimport org.http4s.headers.Authorization\n\nval authUserHeader: Kleisli[IO, Request[IO], Either[String,User]] = Kleisli({ request =>\n  val message = for {\n    header  <- request.headers.get[Authorization]\n                 .toRight(\"Couldn't find an Authorization header\")\n    token   <- crypto.validateSignedToken(header.value)\n                 .toRight(\"Invalid token\")\n    message <- Either.catchOnly[NumberFormatException](token.toLong)\n                 .leftMap(_.toString)\n  } yield message\n  message.traverse(retrieveUser.run)\n})"},{"fileName":"auth.md","title":"Using tsec-http4s for Authentication and Authorization","anchor":"using-tsec-http4s-for-authentication-and-authorization","body":"The TSec project provides an authentication and authorization module\n for the http4s project 0.18-M4+. Docs specific to http4s are located Here."},{"fileName":"auth.md","title":"Implementing authUser","anchor":"implementing-authuser","body":"There's a few different ways to send authorization information with a HTTP\nrequest, the two most common are cookie for regular browser usage or the\nAuthorization header for SPA.\n\n\n"},{"fileName":"cors.md","title":"cors","anchor":null,"body":"CORS\nFor security reasons, modern web browsers enforce a same origin policy,\nrestricting the ability of sites from a given origin\nto access resources at a different origin. Http4s provides Middleware, named CORS, for adding the appropriate headers\nto responses to allow limited exceptions to this via cross origin resource sharing.\nThis guide assumes you are already familiar with CORS and its attendant security risks.\nBy enabling CORS you are bypassing an important protection against malicious third-party\nwebsites - before doing so for any potentially sensitive resource, make sure you understand\nwhat you are doing and why."},{"fileName":"cors.md","title":"Usage","anchor":"usage","body":"Examples in this document have the following dependencies.\nlibraryDependencies ++= Seq(\n  \"org.http4s\" %% \"http4s-dsl\" % http4sVersion,\n  \"org.http4s\" %% \"http4s-server\" % http4sVersion\n)\nAnd we need some imports.\nimport cats.effect._\nimport org.http4s._\nimport org.http4s.dsl.io._\nimport org.http4s.implicits._\nIf you're in a REPL, we also need a runtime:\nimport cats.effect.unsafe.IORuntime\nimplicit val runtime: IORuntime = cats.effect.unsafe.IORuntime.global\nLet's start by making a simple service.\nval service = HttpRoutes.of[IO] {\n  case _ => Ok()\n}\n\nval request = Request[IO](Method.GET, uri\"/\")\nservice.orNotFound(request).unsafeRunSync()\nNow we can wrap the service in the CORS middleware.\nimport org.http4s.server.middleware._\n\nval corsService = CORS.policy.withAllowOriginAll(service)\ncorsService.orNotFound(request).unsafeRunSync()\nSo far, there was no change. That's because an Origin header is required\nin the requests and it must include a scheme. This, of course, is the responsibility of the caller.\nval corsRequest = request.putHeaders(\"Origin\" -> \"https://somewhere.com\")\n\ncorsService.orNotFound(corsRequest).unsafeRunSync()\nNotice how the response has the CORS headers added. How easy was\nthat? And, as described in Middleware, services and middleware can be\ncomposed such that only some of your endpoints are CORS enabled."},{"fileName":"cors.md","title":"Configuration","anchor":"configuration","body":"The example above showed one basic configuration for CORS, which adds the\nheaders to any successful response, regardless of origin or HTTP method. There\nare configuration options to modify that.\nFirst, we'll create some requests to use in our example. We want these requests\nhave a variety of origins and methods.\nval googleGet = Request[IO](Method.GET, uri\"/\",\n  headers = Headers(\"Origin\" -> \"https://google.com\"))\nval yahooPut = Request[IO](Method.PUT, uri\"/\",\n  headers = Headers(\"Origin\" -> \"https://yahoo.com\"))\nval duckPost = Request[IO](Method.POST, uri\"/\",\n  headers = Headers(\"Origin\" -> \"https://duckduckgo.com\"))\nNow, we'll create a configuration that limits the allowed methods to GET\nand POST, pass that to the CORS middleware, and try it out on our requests.\nimport scala.concurrent.duration._\n\nval corsMethodSvc = CORS.policy\n  .withAllowOriginAll\n  .withAllowMethodsIn(Set(Method.GET, Method.POST))\n  .withAllowCredentials(false)\n  .withMaxAge(1.day)\n  .apply(service)\ncorsMethodSvc.orNotFound(googleGet).unsafeRunSync()\ncorsMethodSvc.orNotFound(yahooPut).unsafeRunSync()\ncorsMethodSvc.orNotFound(duckPost).unsafeRunSync()\nAs you can see, the CORS headers were only added to the GET and POST requests.\nNext, we'll create a configuration that limits the origins to \"yahoo.com\" and\n\"duckduckgo.com\". withAllowOriginHost accepts an Origin.Host => Boolean.\nIf you're simply enumerating allowed hosts, a Set is convenient:\nimport org.http4s.headers.Origin\n\nval corsOriginSvc = CORS.policy\n  .withAllowOriginHost(Set(\n    Origin.Host(Uri.Scheme.https, Uri.RegName(\"yahoo.com\"), None),\n    Origin.Host(Uri.Scheme.https, Uri.RegName(\"duckduckgo.com\"), None)\n  ))\n  .withAllowCredentials(false)\n  .withMaxAge(1.day)\n  .apply(service)\ncorsOriginSvc.orNotFound(googleGet).unsafeRunSync()\ncorsOriginSvc.orNotFound(yahooPut).unsafeRunSync()\ncorsOriginSvc.orNotFound(duckPost).unsafeRunSync()\nAgain, the results are as expected. You can, of course, create a configuration that\ncombines limits on HTTP method, origin, and headers.\nAs described in Middleware, services and middleware can be composed such\nthat only some of your endpoints are CORS enabled."},{"fileName":"csrf.md","title":"csrf","anchor":null,"body":"CSRF\nHttp4s provides Middleware, named CSRF, to prevent Cross-site request forgery attacks. This middleware\nis modeled after the double submit cookie pattern.\nExamples in this document have the following dependencies.\nlibraryDependencies ++= Seq(\n  \"org.http4s\" %% \"http4s-dsl\" % http4sVersion,\n  \"org.http4s\" %% \"http4s-server\" % http4sVersion\n)\nAnd we need some imports.\nimport cats.effect._\nimport org.http4s._\nimport org.http4s.dsl.io._\nimport org.http4s.implicits._\nimport org.http4s.server.middleware._\nIf you're in a REPL, we also need a runtime:\nimport cats.effect.unsafe.IORuntime\nimplicit val runtime: IORuntime = cats.effect.unsafe.IORuntime.global\nLet's start by making a simple service.\nval service = HttpRoutes.of[IO] {\n  case _ => Ok()\n}\n\nval request = Request[IO](Method.GET, uri\"/\")\nservice.orNotFound(request).unsafeRunSync()\nThat didn't do all that much. Lets build out our CSRF Middleware by creating a CSRFBuilder\nval cookieName = \"csrf-token\"\nval key  = CSRF.generateSigningKey[IO].unsafeRunSync()\nval defaultOriginCheck: Request[IO] => Boolean =\n  CSRF.defaultOriginCheck[IO](_, \"localhost\", Uri.Scheme.http, None)\nval csrfBuilder = CSRF[IO,IO](key, defaultOriginCheck)\nMore info on what is possible in the CSRFBuilder Docs,\nbut we will create a fairly simple CSRF Middleware in our example.\nval csrf = csrfBuilder\n  .withCookieName(cookieName)\n  .withCookieDomain(Some(\"localhost\"))\n  .withCookiePath(Some(\"/\"))\n  .build\nNow we need to wrap this around our service! We're gonna start with a safe callval dummyRequest: Request[IO] =\n    Request[IO](method = Method.GET).putHeaders(\"Origin\" -> \"http://localhost\")\nval resp = csrf.validate()(service.orNotFound)(dummyRequest).unsafeRunSync()\nNotice how the response has the CSRF cookies added. How easy was\nthat? And, as described in Middleware, services and middleware can be\ncomposed such that only some of your endpoints are CSRF enabled. By default,\nsafe methods will update the CSRF token, while unsafe methods will validate them.\nWithout getting too deep into it, safe methods are OPTIONS, GET, and HEAD. While unsafe methods are\nPOST, PUT, PATCH, DELETE, and TRACE. To put it simply, state changing methods are unsafe. For more information,\ncheck out this cheat sheet on CSRF Prevention.\nUnsafe requests (like POST) require us to send the CSRF token in the X-Csrf-Token\nheader (this is the default name, but it can be changed), so we are going to get the value\nand send it up in our POST. I've also added the response cookie as a RequestCookie, normally\nthe browser would send this up with our request, but I needed to do it manually for the purpose of this demo.val cookie = resp.cookies.head\nval dummyPostRequest: Request[IO] =\n    Request[IO](method = Method.POST).putHeaders(\n      \"Origin\" -> \"http://localhost\",\n      \"X-Csrf-Token\" -> cookie.content\n    ).addCookie(RequestCookie(cookie.name,cookie.content))\nval validateResp =\n  csrf.validate()(service.orNotFound)(dummyPostRequest).unsafeRunSync()"},{"fileName":"gzip.md","title":"gzip","anchor":null,"body":"GZip Compression\nHttp4s provides the GZip middleware for compressing Response bodies using gzip compression.\nimport cats.effect.{IO, IOApp}\nimport org.http4s.dsl.io._\nimport org.http4s.HttpRoutes\nimport org.http4s.ember.server.EmberServerBuilder\nimport org.http4s.server.middleware.GZip\n\nobject GZipExample extends IOApp.Simple {\n\n  val service = HttpRoutes.of[IO] {\n    case _ => Ok(\"Hello!\")\n  }.orNotFound\n\n  val gzippedService = GZip(service)\n\n  val run = EmberServerBuilder\n    .default[IO]\n    .withHttpApp(gzippedService)\n    .build\n    .useForever\n}"},{"fileName":"gzip.md","title":"Setup","anchor":"setup","body":"Examples in this document have the following dependencies.\nval http4sVersion = \"@VERSION@\"\n\nlibraryDependencies ++= Seq(\n  \"org.http4s\" %% \"http4s-dsl\" % http4sVersion,\n  \"org.http4s\" %% \"http4s-server\" % http4sVersion\n)\nWe'll create a basic service, without any middleware, and a request to test with:\nimport cats.effect.IO\nimport org.http4s._\nimport org.http4s.dsl.io._\nimport org.http4s.implicits._\n\nval service = HttpRoutes.of[IO] {\n  case _ =>\n    Ok(\"I repeat myself when I'm under stress. \" * 3)\n}\n\nval request = Request[IO](Method.GET, uri\"/\")\nBecause this documentation is running in mdoc we need an implicit IORuntime to let us run our IO values explicitly with .unsafeRunSync().\nIn real code you should construct your whole program in IO and assign it to run in IOApp as in the example above.import cats.effect.unsafe.IORuntime\nimplicit val runtime: IORuntime = IORuntime.global"},{"fileName":"gzip.md","title":"GZip","anchor":"gzip","body":"Let's start by making a simple service that returns a (relatively) large string\nin its body. We'll use as[String] to examine the body.\n\nval response = service.orNotFound(request).unsafeRunSync()\nval body = response.as[String].unsafeRunSync()\nbody.length\nNow we can wrap the service in the GZip middleware.\nimport org.http4s.server.middleware.GZip\n\nval serviceZip = GZip(service)\nval respNormal = serviceZip.orNotFound(request).unsafeRunSync()\nval bodyNormal = respNormal.as[String].unsafeRunSync()\nbodyNormal.length\nSo far, there was no change. That's because the caller needs to inform us that\nthey will accept GZipped responses via an Accept-Encoding header. Acceptable\nvalues for the Accept-Encoding header are \"gzip\", \"x-gzip\", and \"*\".\nval requestZip =\n  request.putHeaders(\"Accept-Encoding\" -> \"gzip\")\nval respZip = serviceZip.orNotFound(requestZip).unsafeRunSync()\nval bodyZip = respZip.as[String].unsafeRunSync()\nbodyZip.length\nNotice how the response no longer looks very String-like and it's shorter in\nlength. Also, there is a Content-Encoding header in the response with a value\nof \"gzip\".\nAs described in middleware, services and middleware can be composed such\nthat only some of your endpoints are GZip enabled."},{"fileName":"hsts.md","title":"hsts","anchor":null,"body":"HTTP Strict Transport Security\nHttp4s provides a Middleware giving support for HTTP Strict Transport Security (HSTS).\nThe middleware is called HSTS and simply adds a header to enable a HSTS security policy.\nThough it is not enforced, HSTS only makes sense for an https service.\nExamples in this document have the following dependencies.\nlibraryDependencies ++= Seq(\n  \"org.http4s\" %% \"http4s-dsl\" % http4sVersion,\n  \"org.http4s\" %% \"http4s-server\" % http4sVersion\n)\nAnd we need some imports.\nimport org.http4s._\nimport org.http4s.dsl.io._\nimport org.http4s.implicits._\nimport cats.effect.IO\nIf you're in a REPL, we also need a runtime:\nimport cats.effect.unsafe.IORuntime\nimplicit val runtime: IORuntime = cats.effect.unsafe.IORuntime.global\nLet's make a simple service that will be exposed and wrapped with HSTS.\nval service = HttpRoutes.of[IO] {\n  case _ => Ok(\"ok\")\n}\n\nval request = Request[IO](Method.GET, uri\"/\")\n// Do not call 'unsafeRunSync' in your code\nval responseOk = service.orNotFound(request).unsafeRunSync()\nresponseOk.headers\nIf we were to wrap this on the HSTS middleware.\nimport org.http4s.server.middleware._\n\nval hstsService = HSTS(service)\n// Do not call 'unsafeRunSync' in your code\nval responseHSTS = hstsService.orNotFound(request).unsafeRunSync()\nresponseHSTS.headers\nNow the response has the Strict-Transport-Security header which will mandate browsers\nsupporting HSTS to always connect using https.\nAs described in Middleware, services and middleware can be composed though HSTS\nis something you may want enabled across all your routes."},{"fileName":"hsts.md","title":"Configuration","anchor":"configuration","body":"By default HSTS is configured to indicate that all requests during 1 year\nshould be done over https and it will contain the includeSubDomains directive by default.\nIf you want to preload or change other default values you can pass a custom header, e.g.\nimport org.http4s.headers._\nimport scala.concurrent.duration._\n\nval hstsHeader = `Strict-Transport-Security`\n  .unsafeFromDuration(30.days, includeSubDomains = true, preload = true)\nval hstsServiceCustom = HSTS(service, hstsHeader)\n// Do not call 'unsafeRunSync' in your code\nval responseCustom = hstsServiceCustom.orNotFound(request).unsafeRunSync()\nresponseCustom.headers"},{"fileName":"hsts.md","title":"References","anchor":"references","body":"RFC-6797HSTS Cheat Sheet"},{"fileName":"static.md","title":"static","anchor":null,"body":"Static Files\nHttp4s can serve static files, subject to a configuration policy. There are three\nlocations that Http4s can serve static content from: the filesystem, resources\nusing the classloader, and WebJars.\nAll of these solutions are most likely slower than the equivalent in nginx or a\nsimilar static file hoster, but they're often fast enough."},{"fileName":"static.md","title":"Getting Started","anchor":"getting-started","body":"To use fileService, the only configuration required is the relative path to the directory to serve.\nThe service will automatically serve index.html if the request path is not a file. This service will also\nremove dot segments, to prevent attackers from reading files not contained in the directory\nbeing served.\nimport cats.effect._\nimport com.comcast.ip4s._\nimport org.http4s.ember.server.EmberServerBuilder\nimport org.http4s.server.Server\nimport org.http4s.server.staticcontent._\n\nobject SimpleHttpServer extends IOApp {\n  override def run(args: List[String]): IO[ExitCode] =\n    app.use(_ => IO.never).as(ExitCode.Success)\n\n  val app: Resource[IO, Server] =\n    EmberServerBuilder\n      .default[IO]\n      .withHost(ipv4\"0.0.0.0\")\n      .withPort(port\"8080\")\n      .withHttpApp(fileService[IO](FileService.Config(\".\")).orNotFound)\n      .build\n}\nStatic content services can be composed into a larger application by using a Router:val httpApp: HttpApp[IO] =\n    Router(\n      \"api\"    -> anotherService,\n      \"assets\" -> fileService(FileService.Config(\"./assets\"))\n    ).orNotFound"},{"fileName":"static.md","title":"ETags","anchor":"etags","body":"Usually, if you fetch a file via HTTP, it ships with an ETag. An ETag specifies\na file version. So the next time the browser requests that information, it sends\nthe ETag along, and gets a 304 Not Modified back, so you don't have to send the\ndata over the wire again."},{"fileName":"static.md","title":"Inline in a Route","anchor":"inline-in-a-route","body":"For custom behaviour, StaticFile.fromPath can also be used directly in a route, to respond with a file:\nimport org.http4s._\nimport org.http4s.dsl.io._\nimport fs2.io.file.Path\n\nval routes = HttpRoutes.of[IO] {\n  case request @ GET -> Root / \"index.html\" =>\n    StaticFile.fromPath(Path(\"relative/path/to/index.html\"), Some(request))\n      .getOrElseF(NotFound()) // In case the file doesn't exist\n}"},{"fileName":"static.md","title":"Serving from JARs","anchor":"serving-from-jars","body":"For simple file serving, it's possible to package resources with the jar and\ndeliver them from there. For example, for all resources in the classpath under assets:\nval assetsRoutes = resourceServiceBuilder[IO](\"/assets\").toRoutes\nFor custom behaviour, StaticFile.fromResource can be used. In this example,\nonly files matching a list of extensions are served. Append to the List as needed.\ndef static(file: String, request: Request[IO]) =\n  StaticFile.fromResource(\"/\" + file, Some(request)).getOrElseF(NotFound())\n\nval fileTypes = List(\".js\", \".css\", \".map\", \".html\", \".webm\")\n\nval fileRoutes = HttpRoutes.of[IO] {\n  case request @ GET -> Root / path if fileTypes.exists(path.endsWith) =>\n    static(path, request)\n}"},{"fileName":"static.md","title":"Webjars","anchor":"webjars","body":"A special service exists to load files from WebJars. Add your WebJar to the\nclass path, as you usually would:\nlibraryDependencies ++= Seq(\n  \"org.webjars\" % \"jquery\" % \"3.1.1-1\"\n)\nThen, mount the WebjarService like any other service:\nimport org.http4s.server.staticcontent.WebjarServiceBuilder.WebjarAsset\n// only allow js assets\ndef isJsAsset(asset: WebjarAsset): Boolean =\n  asset.asset.endsWith(\".js\")\n\nval webjars: HttpRoutes[IO] = webjarServiceBuilder[IO]\n  .withWebjarAssetFilter(isJsAsset)\n  .toRoutes\nAssuming that the service is mounted as root on port 8080, and you included the webjar swagger-ui-3.20.9.jar on your classpath, you would reach the assets with the path: http://localhost:8080/swagger-ui/3.20.9/index.html"},{"fileName":"client.md","title":"client","anchor":null,"body":"HTTP Client\nThe Client trait in http4s can submit a Request to a server and return a Response.\ntrait Client[F[_]] {\n\n  def run(req: Request[F]): Resource[F, Response[F]]\n\n  //...\n}\nWhile Client is abstract in its effect type F, we will use concrete IO throughout this guide.\nLet's briefly chat about the Resource wrapping the return type.\nEvery request/response pair is transmitted over a connection, which is a finite resource.\nWhen you are done reading the Response, you return from the Resource.\nThis releases the connection so that it may be re-used by another request/response pair, or shutdown.\nHere's a quick example app to print the response of a GET request.\nimport cats.effect.{IO, IOApp}\nimport org.http4s.ember.client.EmberClientBuilder\nimport org.http4s.client.Client\n\nobject Hello extends IOApp.Simple {\n\n  def printHello(client: Client[IO]): IO[Unit] =\n    client\n      .expect[String](\"http://localhost:8080/hello/Ember\")\n      .flatMap(IO.println)\n\n  val run: IO[Unit] = EmberClientBuilder\n    .default[IO]\n    .build\n    .use(client => printHello(client))\n\n}"},{"fileName":"client.md","title":"Setup","anchor":"setup","body":"In order to play with a Client we'll first create an http4s Server.\nEnsure you have the following dependencies in your build.sbt:\nscalaVersion := \"2.13.8\" // Also supports 2.12.x and 3.x\n\nval http4sVersion = \"@VERSION@\"\n\nlibraryDependencies ++= Seq(\n  \"org.http4s\" %% \"http4s-ember-client\" % http4sVersion,\n  \"org.http4s\" %% \"http4s-ember-server\" % http4sVersion,\n  \"org.http4s\" %% \"http4s-dsl\"          % http4sVersion,\n)\nNow we can finish setting up our server:\nimport com.comcast.ip4s._\nimport org.http4s._\nimport org.http4s.dsl.io._\nimport org.http4s.implicits._\nimport org.http4s.ember.server.EmberServerBuilder\nimport org.http4s.server.middleware.Logger\n\nval app = HttpRoutes.of[IO] {\n  case GET -> Root / \"hello\" / name =>\n    Ok(s\"Hello, $name.\")\n}.orNotFound\n\nval finalHttpApp = Logger.httpApp(true, true)(app)\n\nval server = EmberServerBuilder\n  .default[IO]\n  .withHost(ipv4\"0.0.0.0\")\n  .withPort(port\"8080\")\n  .withHttpApp(finalHttpApp)\n  .build\nBecause this documentation is running in mdoc we need an implicit IORuntime to let us run our IO values explicitly with .unsafeRunSync().\nIn real code you should construct your whole program in IO and assign it to run in IOApp as in the example above.import cats.effect.unsafe.IORuntime\nimplicit val runtime: IORuntime = IORuntime.globalIf you are following along in a REPL you will need to start the server in the background.\nAdditionally you will want a way to shutdown the server when you're done.You can do this by starting the server like so:val shutdown = server.allocated.unsafeRunSync()._2Later you can call shutdown.unsafeRunSync() to run the server's finalizers and release resources."},{"fileName":"client.md","title":"Creating the client","anchor":"creating-the-client","body":"A good default choice is the EmberClientBuilder.\nThe EmberClientBuilder sets up a connection pool, enabling the reuse of connections for multiple requests, supports HTTP/1.x and HTTP/2, and is available for ScalaJS.\nimport org.http4s.ember.client.EmberClientBuilder\n\nEmberClientBuilder\n  .default[IO]\n  .build\n  .use { client =>\n    // use `client` here, returning an `IO`.\n    client.expect[String](\"http://localhost:8080/hello/Ember\")\n}\nIn the above example .build returns a Resource[IO, Client].\nWe use the Client by passing use a function Client => IO[B].\nThe result is a value that, when run, will acquire a Client, use it, and release it (even under cancellation or errors).\nNote that we generally only call .build.use once per application and pass around the Client.\nSee the Quick Start g8 template for an example.\nFor the remainder of this tutorial, we'll use an alternate client backend\nbuilt on the standard java.net library client.  Unlike the ember\nclient, it does not need to be shut down.  Like the ember-client, and\nany other http4s backend, it presents the exact same Client\ninterface!\nIt uses blocking I/O and is not suited for production, but it is\nhighly useful in a REPL or mdoc documentation:\nimport org.http4s.client.JavaNetClientBuilder\n\n// for REPL or mdoc use only!\nval httpClient: Client[IO] = JavaNetClientBuilder[IO].create"},{"fileName":"client.md","title":"Describing a Request","anchor":"describing-a-request","body":"To execute a GET request, we can call expect with the type we expect\nand the URI we want:\nval helloEmber: IO[String] =\n  httpClient.expect[String](\"http://localhost:8080/hello/Ember\")\nWe don't have any output from the server yet as we have not executed the request.\nWe have an IO[String] value, which is a description of a program that, when run,\nwill send a GET request to the server, and expect a plain text String response.\nLet's build another program that makes requests in parallel to greet a\ncollection of people:\nimport cats.effect.IO\nimport cats.syntax.all._\nimport org.http4s.Uri\n\ndef hello(name: String): IO[String] = {\n  val target = uri\"http://localhost:8080/hello/\" / name\n  httpClient.expect[String](target)\n}\n\nval inputs = List(\"Ember\", \"http4s\", \"Scala\")\n\nval getGreetings: IO[List[String]] =\n  inputs.parTraverse(hello)\nWe use parTraverse to apply hello to each name and collect the results into\none IO[List[String]].\nThe par prefix (as in \"parallel\") on parTraverse indicates that this\nwill happen concurrently not sequentially."},{"fileName":"client.md","title":"Running a Request","anchor":"running-a-request","body":"We have built two programs: helloEmber will make a single request to get a greeting for Ember,\nand getGreetings will make multiple concurrent requests getting multiple greetings.\nIn a production application we would likely compose these programs with other programs\nup until we finally pass them to run in IOApp as seen in our intro example.\nHere in mdoc, or in a REPL, we manually run the IO with unsafeRunSync().\nRemember, you should not do this in your applications.\nhelloEmber.unsafeRunSync()\n\ngetGreetings.unsafeRunSync()"},{"fileName":"client.md","title":"Making Requests","anchor":"making-requests","body":"\n\n"},{"fileName":"client.md","title":"Constructing a URI","anchor":"constructing-a-uri","body":"Typically, to construct a Request, you use a Uri to represent the endpoint you\nwant to access.\nThere are a number of ways to construct a Uri.\nIf you have a literal string, you can use the uri string interpolator:\nuri\"https://my-awesome-service.com/foo/bar?wow=yeah\"\nThis only works with literal strings because it uses a macro to validate the URI\nformat at compile-time.\nOtherwise, you'll need to use Uri.fromString(...) and handle the case where\nvalidation fails:\nval validUri = \"https://my-awesome-service.com/foo/bar?wow=yeah\"\nval invalidUri = \"yeah whatever\"\nval uri: ParseResult[Uri] = Uri.fromString(validUri)\n\nval parseFailure: ParseResult[Uri] = Uri.fromString(invalidUri)\nYou can also build up a URI incrementally, e.g.:\nval baseUri: Uri = uri\"http://foo.com\"\nval withPath: Uri = baseUri.withPath(path\"/bar/baz\")\nval withQuery: Uri = withPath.withQueryParam(\"hello\", \"world\")"},{"fileName":"client.md","title":"Included Middleware","anchor":"included-middleware","body":"Http4s includes some middleware Out of the Box in the org.http4s.client.middleware\npackage. These include:\nFollowing of redirect responses (Follow Redirect)Retrying of requests (Retry)Metrics gathering (Metrics)Logging of requests (Request Logger)Logging of responses (Response Logger)Logging of requests and responses (Logger)"},{"fileName":"client.md","title":"Metrics Middleware","anchor":"metrics-middleware","body":"Apart from the middleware mentioned in the previous section. There is, as well,\nOut of the Box middleware for Dropwizard and Prometheus metrics."},{"fileName":"client.md","title":"Middleware","anchor":"middleware","body":"Like the server middleware, the client middleware is a wrapper around a\nClient that provides a means of accessing or manipulating Requests\nand Responses being sent.\nConsider functions from Int to String. We could create a wrapper over functions of this type,\nwhich would take an Int => String and return an Int => String.\nSuch a wrapper could make the result inspect its input, do something to it,\nand call the original function with that input (or even another one).\nThen it could look at the response and also make some actions based on it.\nAn example wrapper could look something like this:\ndef mid(f: Int => String): Int => String = in => {\n  // `in` is the input originally passed to the function.\n  // We can pass it to `f` directly.\n  // Or use it to construct a new value.\n  val resultOfF = f(in + 1)\n\n  // `resultOfF` is the result of the function applied to the new input.\n  // Similarly, we can return it directly, or build a new value.\n  s\"$in was incremented to yield $resultOfF\"\n}\nIf we wrap a simple function, say, one returning the String representation of a number:\nval f1: Int => String = _.toString\n\n// Here, we're applying our wrapper to `f1`. Notice that this is still a function.\nval f2: Int => String = mid(f1)\n\nf1(10)\nf2(10)\nWe see how f2 wraps f1 by passing an incremented argument to the original function.\nThis wrapper could be considered a middleware over functions from Int to String.\nRecall our simplified definition of Client[F] - it boils down to a single abstract method:\ntrait Client[F[_]] {\n  def run(request: Request[F]): Resource[F, Response[F]]\n}\nKnowing this, we could say a Client[F] is equivalent to a function from Request[F] to Resource[F, Response[F]]. In fact, given a client, we could call client.run _ to get that function.\nA client middleware follows the same idea as our original middleware did: it takes a Client (which is a function) and returns another Client (which is also a function).\nIt can see the input Request[F] that we pass to the client when we call it, it can modify that request, pass it to the underlying client (or any other client, really!), and do all sorts of other things, including effects - all it has to do is return a Resource[F, Response[F]].\nThe real definition of Client is a little more complicated because there's several more abstract methods.\nIf you want to implement a client using just a function (for example, to make a middleware), consider using Client.apply.\nA simple middleware, which would add a constant header to every request and response, could look like this:\nimport cats.effect.MonadCancelThrow\nimport org.typelevel.ci._\n\ndef addTestHeader[F[_]: MonadCancelThrow](underlying: Client[F]): Client[F] = Client[F] { req =>\n  underlying\n    .run(\n      req.withHeaders(Header.Raw(ci\"X-Test-Request\", \"test\"))\n    )\n    .map(\n      _.withHeaders(Header.Raw(ci\"X-Test-Response\", \"test\"))\n    )\n}\nAs the caller of the client you would get from this, you would see the extra header in the response.\nSimilarly, every service called by the client would see an extra header in the requests.\n\n"},{"fileName":"client.md","title":"Send a GET request","anchor":"send-a-get-request","body":"You can send a GET by calling the expect method on the client, passing a Uri:\nhttpClient.expect[String](uri\"https://google.com/\")\nIf you need to do something more complicated like setting request headers, you\ncan build up a request object and pass that to expect:\nimport cats.effect.IO\nimport org.http4s.Request\nimport org.http4s.Headers\nimport org.http4s.headers._\nimport org.http4s.MediaType\n\nval request = Request[IO](\n  method = Method.GET,\n  uri = uri\"https://my-lovely-api.com/\",\n  headers = Headers(\n    Authorization(Credentials.Token(AuthScheme.Bearer, \"open sesame\")),\n    Accept(MediaType.application.json),\n  )\n)\n\nhttpClient.expect[String](request)"},{"fileName":"client.md","title":"Send a POST request","anchor":"send-a-post-request","body":"You can send a POST request and decode the JSON response into a case class\nby deriving an EntityDecoder for that case class:\nimport cats.effect.IO\nimport org.http4s.circe._\nimport io.circe.generic.auto._\n\ncase class AuthResponse(access_token: String)\n\nimplicit val authResponseEntityDecoder: EntityDecoder[IO, AuthResponse] = jsonOf\n\nval postRequest = Request[IO](\n  method = Method.POST, \n  uri = uri\"https://my-lovely-api.com/oauth2/token\"\n).withEntity(\n  UrlForm(\n    \"grant_type\" -> \"client_credentials\",\n    \"client_id\" -> \"my-awesome-client\",\n    \"client_secret\" -> \"s3cr3t\"\n  )\n)\n\nhttpClient.expect[AuthResponse](postRequest)\nshutdown.unsafeRunSync()"},{"fileName":"client.md","title":"Examples","anchor":"examples","body":"\n"},{"fileName":"client.md","title":"Calls to a JSON API","anchor":"calls-to-a-json-api","body":"Take a look at json."},{"fileName":"client.md","title":"Body decoding / encoding","anchor":"body-decoding-encoding","body":"The reusable way to decode or encode a request is to write a custom EntityDecoder\nor EntityEncoder. For that topic, take a look at entity.\nIf you prefer a more fine-grained approach, some of the methods on Client take a\nResponse[F] => F[A] argument, such as get, which lets you add a function which\nincludes the decoding functionality, but ignores the media type.\nval endpoint = uri\"http://localhost:8080/hello/Ember\"\nhttpClient.get[Either[String, String]](endpoint) {\n  case Status.Successful(r) => r.attemptAs[String].leftMap(_.message).value\n  case r => r.as[String]\n    .map(b => Left(s\"Request failed with status ${r.status.code} and body $b\"))\n}\nYour function has to consume the body before the returned F exits.\nResponse.body yields a EntityBody which is a type alias for Stream[F, Byte].\nIt's this Stream that needs to be consumed within your effect F.\nDo not do this:\nimport org.http4s.EntityBody\n\n// response.body is not consumed within `F`\nhttpClient.get[EntityBody[IO]](\"some-url\")(response => IO(response.body))"},{"fileName":"entity.md","title":"entity","anchor":null,"body":"Entity Handling"},{"fileName":"entity.md","title":"Why Entity*","anchor":"why-entity","body":"Http4s handles HTTP requests and responses in a streaming fashion. Your service\nwill receive a request after the header has been parsed (ok, not 100%\nstreaming), but before the body has been fully received. The same applies to the\nhttp client usage, where you can start a connection before the body is fully\nmaterialized. You don't have to load the full body into memory to submit the\nrequest either. Taking a look at Request[F] and Response[F], both have a body of\ntype EntityBody[F], which is simply an alias to Stream[F, Byte]. To\nunderstand Stream, take a look at the introduction-to-functional-streams.\nThe EntityDecoder and EntityEncoder help with the streaming nature of the\ndata in a http body, and they also have additional logic to deal with media\ntypes. Not all decoders are streaming, depending on the implementation."},{"fileName":"entity.md","title":"Construction and Media Types","anchor":"construction-and-media-types","body":"Entity*s also encode which media types they correspond to. The\nEntityDecoders for json expect application/json. To implement this\nfunctionality, the constructor EntityDecoder.decodeBy uses MediaRanges. You\ncan pass multiple as needed. You can also append functionality to an existing\none via EntityDecoder[F, T].map - however, you can't change the media\ntype in that case.\nWhen you encode a body with the EntityEncoder for json, it appends the\nContent-Type: application/json header. You can construct new encoders via\nEntityEncoder.encodeBy or reuse an already existing one via\nEntityEncoder[F, T].contramap and withContentType.\nSee the MediaRange companion object for ranges, and MediaType for specific\ntypes. Because of the implicit conversions, you can also use (String, String)\nfor a MediaType.\nBy default, decoders content types are ignored since it could lead to unexpected\nruntime errors."},{"fileName":"entity.md","title":"Chaining Decoders","anchor":"chaining-decoders","body":"Decoders' content types are used when chaining decoders with orElse in order to\ndetermine which of the chained decoders are to be used.\nimport org.http4s._\nimport org.http4s.headers.`Content-Type`\nimport org.http4s.dsl.io._\nimport cats._, cats.effect._, cats.implicits._, cats.data._\n\nsealed trait Resp\ncase class Audio(body: String) extends Resp\ncase class Video(body: String) extends Resp\nIf you're in a REPL, we also need a runtime:\nimport cats.effect.unsafe.IORuntime\nimplicit val runtime: IORuntime = cats.effect.unsafe.IORuntime.global\nval response = Ok(\"\").map(_.withContentType(`Content-Type`(MediaType.audio.ogg)))\nval audioDec = EntityDecoder.decodeBy(MediaType.audio.ogg) { (m: Media[IO]) =>\n  EitherT {\n    m.as[String].map(s => Audio(s).asRight[DecodeFailure])\n  }\n}\nval videoDec = EntityDecoder.decodeBy(MediaType.video.ogg) { (m: Media[IO]) =>\n  EitherT {\n    m.as[String].map(s => Video(s).asRight[DecodeFailure])\n  }\n}\nimplicit val bothDec = audioDec.widen[Resp] orElse videoDec.widen[Resp]\nprintln(response.flatMap(_.as[Resp]).unsafeRunSync())"},{"fileName":"entity.md","title":"Raw Data Types","anchor":"raw-data-types","body":"These are already in implicit scope by default, e.g. String, File, and InputStream. Consult EntityEncoder and EntityDecoder for\na full list."},{"fileName":"entity.md","title":"JSON","anchor":"json","body":"With jsonOf for the EntityDecoder, and jsonEncoderOf for the EntityEncoder:\ncirce: \"org.http4s\" %% \"http4s-circe\" % http4sVersion"},{"fileName":"entity.md","title":"XML","anchor":"xml","body":"For scala-xml (xml literals), import org.http4s.scalaxml. No direct naming\nrequired here, because there is no Decoder instance for String that would\ncause conflicts with the builtin Decoders.\nscala-xml: \"org.http4s\" %% \"http4s-scala-xml\" % http4sVersion"},{"fileName":"entity.md","title":"Support for Twirl and Scalatags","anchor":"support-for-twirl-and-scalatags","body":"If you're working with either twirl or scalatags you can use our bridges:\nscala-twirl: \"org.http4s\" %% \"http4s-twirl\" % http4sVersionscala-scalatags: \"org.http4s\" %% \"http4s-scalatags\" % http4sVersion"},{"fileName":"entity.md","title":"Presupplied Encoders/Decoders","anchor":"presupplied-encoders-decoders","body":"The EntityEncoder/EntityDecoders shipped with http4s.\n\n\n\n"},{"fileName":"streaming.md","title":"streaming","anchor":null,"body":"Streaming\nStreaming lies at the heart of the http4s model of HTTP, in the literal sense that EntityBody[F]\nis just a type alias for Stream[F, Byte]. Please see entity for details. This means\nHTTP streaming is provided by both http4s' service support and its client support."},{"fileName":"streaming.md","title":"Streaming responses from your service","anchor":"streaming-responses-from-your-service","body":"Because EntityBody[F]s are streams anyway, returning a stream as a response from your service is\nsimplicity itself:\nimport scala.concurrent.duration._\n\nimport cats.effect._\nimport fs2.Stream\nimport org.http4s._\nimport org.http4s.dsl.io._\n\n// An infinite stream of the periodic elapsed time\nval seconds = Stream.awakeEvery[IO](1.second)\n\nval routes = HttpRoutes.of[IO] {\n  case GET -> Root / \"seconds\" =>\n    Ok(seconds.map(_.toString)) // `map` `toString` because there's no `EntityEncoder` for `Duration`\n}\nStreams are returned to the client as chunked HTTP responses automatically. You don't need to provide the header yourself.\nFor a more realistic example of streaming results from database queries to the client, please see the\nScalaSyd 2015 example. In particular, if you want to stream JSON responses, please take note of how\nit converts a stream of JSON objects to a JSON array, which is friendlier to clients."},{"fileName":"streaming.md","title":"Consuming Streams with the Client","anchor":"consuming-streams-with-the-client","body":"The http4s client supports consuming chunked HTTP responses as a stream, again because the\nEntityBody[F] is a stream anyway. http4s' Client interface consumes streams with the streaming\nfunction, which takes a Request[F] and a Response[F] => Stream[F, A] and returns a\nStream[F, A]. Since an EntityBody[F] is just a Stream[F, Byte], then, the easiest way\nto consume a stream is just:\nclient.stream(req).flatMap(_.body)\nThat gives you a Stream[F, Byte], but you probably want something other than a Byte.\nHere's some code intended to consume Twitter's streaming APIs, which return a stream of JSON.\nFirst, let's assume we want to use Circe for JSON support. Please see json for details.\nlibraryDependencies ++= Seq(\n  \"org.http4s\" %% \"http4s-circe\" % \"@VERSION@\",\n  \"io.circe\" %% \"circe-generic\" % \"@CIRCE_VERSION@\"\n)\nNext, we want streaming JSON. Because http4s is streaming in its bones, it relies on jawn for\nstreaming JSON support. Most popular JSON libraries, including Circe, provide jawn support, as\nthe code below shows. What's left is to integrate jawn's streaming parsing with fs2's Stream.\nThat's done by jawn-fs2, which http4s' Circe module depends on transitively.\nBecause Twitter's Streaming APIs literally return a stream of JSON objects, not a JSON array,\nwe want to use jawn-fs2's parseJsonStream.\nFinally, Twitter's Streaming APIs also require OAuth authentication. So our example is an OAuth\nexample as a bonus!\nPutting it all together into a small app that will print the JSON objects forever:\nimport org.http4s._\nimport org.http4s.ember.client._\nimport org.http4s.client.oauth1\nimport org.http4s.client.oauth1.ProtocolParameter._\nimport org.http4s.implicits._\nimport cats.effect._\nimport fs2.Stream\nimport fs2.io.stdout\nimport fs2.text.{lines, utf8}\nimport io.circe.Json\nimport org.typelevel.jawn.fs2._\n\nclass TWStream[F[_]: Async] {\n  // jawn-fs2 needs to know what JSON AST you want\n  implicit val f = new io.circe.jawn.CirceSupportParser(None, false).facade\n\n  /* These values are created by a Twitter developer web app.\n   * OAuth signing is an effect due to generating a nonce for each `Request`.\n   */\n  def sign(consumerKey: String, consumerSecret: String,\n             accessToken: String, accessSecret: String)\n          (req: Request[F]): F[Request[F]] = {\n    val consumer = Consumer(consumerKey, consumerSecret)\n    val token    = Token(accessToken, accessSecret)\n    oauth1.signRequest(\n      req,\n      consumer,\n      Some(token),\n      realm = None,\n      timestampGenerator = Timestamp.now,\n      nonceGenerator = Nonce.now,\n      )\n  }\n\n  /* Create a http client, sign the incoming `Request[F]`, stream the `Response[IO]`, and\n   * `parseJsonStream` the `Response[F]`.\n   * `sign` returns a `F`, so we need to `Stream.eval` it to use a for-comprehension.\n   */\n  def jsonStream(consumerKey: String, consumerSecret: String, \n                   accessToken: String, accessSecret: String)\n                  (req: Request[F]): Stream[F, Json] =\n    for {\n      client <- Stream.resource(EmberClientBuilder.default[F].build)\n      sr  <- Stream.eval(sign(consumerKey, consumerSecret, accessToken, accessSecret)(req))\n      res <- client.stream(sr).flatMap(_.body.chunks.parseJsonStream)\n    } yield res\n\n  /* Stream the sample statuses.\n   * Plug in your four Twitter API values here.\n   * We map over the Circe `Json` objects to pretty-print them with `spaces2`.\n   * Then we `to` them to fs2's `lines` and then to `stdout` `Sink` to print them.\n   */\n  val stream: Stream[F, Unit] = {\n    val req = Request[F](Method.GET, \n                uri\"https://stream.twitter.com/1.1/statuses/sample.json\")\n    val s   = jsonStream(\"<consumerKey>\", \"<consumerSecret>\",\n                \"<accessToken>\", \"<accessSecret>\")(req)\n    s.map(_.spaces2).through(lines).through(utf8.encode).through(stdout)\n  }\n\n  /** Compile our stream down to an effect to make it runnable */\n  def run: F[Unit] =\n    stream.compile.drain\n}\nTWStream runs any effect type supported by cats-effect.  We need to\npick a concrete effect, such as cats.effect.IO, to actually run it.\nWe'll make use of cats.effect.IOApp, which defines a program in terms\nin the form run(args: List[String]): IO[ExitCode]:\nobject TWStreamApp extends IOApp {\n  def run(args: List[String]) =\n    (new TWStream[IO]).run.as(ExitCode.Success)\n}"},{"fileName":"json.md","title":"json","anchor":null,"body":"JSON Handling"},{"fileName":"json.md","title":"Circe","anchor":"circe","body":"The http4s team recommends circe.  Only http4s-circe is required for\nbasic interop with circe, but to follow this tutorial, install all three:\nval http4sVersion = \"@VERSION@\"\n\nlibraryDependencies ++= Seq(\n  \"org.http4s\" %% \"http4s-circe\" % http4sVersion,\n  // Optional for auto-derivation of JSON codecs\n  \"io.circe\" %% \"circe-generic\" % \"@CIRCE_VERSION@\",\n  // Optional for string interpolation to JSON model\n  \"io.circe\" %% \"circe-literal\" % \"@CIRCE_VERSION@\"\n)\n\naddCompilerPlugin(\"org.scalamacros\" % \"paradise\" % \"2.1.0\" cross CrossVersion.full)\nIf you're in a REPL, we also need a runtime:\nimport cats.effect.unsafe.IORuntime\nimplicit val runtime: IORuntime = cats.effect.unsafe.IORuntime.global"},{"fileName":"json.md","title":"Add the JSON support module(s)","anchor":"add-the-json-support-module-s","body":"http4s-core does not include JSON support, but integration with some\npopular Scala JSON libraries are supported as modules.\n"},{"fileName":"json.md","title":"Sending Raw JSON","anchor":"sending-raw-json","body":"Let's create a function to produce a simple JSON greeting with circe. First, the imports:\nimport cats.effect._\nimport io.circe._\nimport io.circe.literal._\nimport org.http4s._\nimport org.http4s.dsl.io._\nimport org.http4s.implicits._\nUnder some setup options (we saw this in Scala 3.1.2 but not in 3.1.0), running import io.circe._ might give you an error of -- [E008] Not Found Error: value circe is not a member of io. This means that io is shadowed from some other package. In that case, you should run import _root_.io.circe._, analogously for the other circe imports.\nThen the actual code:\ndef hello(name: String): Json =\n  json\"\"\"{\"hello\": $name}\"\"\"\n\nval greeting = hello(\"world\")\nWe now have a JSON value, but we don't have enough to render it:\nOk(greeting).unsafeRunSync()\nTo encode a Scala value of type A into an entity, we need an\nEntityEncoder[A] in scope.  The http4s-circe module includes a\norg.http4s.circe object, which gives us exactly this for an\nio.circe.Json value:\nimport org.http4s.circe._\nOk(greeting).unsafeRunSync()\nThe same EntityEncoder[Json] we use on server responses is also\nuseful on client requests:\nRequest[IO](Method.POST, uri\"/hello\")\n  .withEntity(json\"\"\"{\"name\": \"Alice\"}\"\"\")"},{"fileName":"json.md","title":"Encoding case classes as JSON","anchor":"encoding-case-classes-as-json","body":"These JSON literals are nice, but in real apps, we prefer to operate\non case classes and use JSON as a serialization format near the edge\nof the world.\nLet's define a couple case classes:\ncase class Hello(name: String)\ncase class User(name: String)\nTo transform a value of type A into Json, circe uses an\nio.circe.Encoder[A].  With circe's syntax, we can convert any value\nto JSON as long as an implicit Encoder is in scope:\nimport io.circe.syntax._\n\nimplicit val HelloEncoder: Encoder[Hello] =\n  Encoder.instance { (hello: Hello) =>\n    json\"\"\"{\"hello\": ${hello.name}}\"\"\"\n  }\n\nHello(\"Alice\").asJson\nThat was easy, but gets tedious for applications dealing in lots of\ntypes.  Fortunately, circe can automatically derive an encoder for us,\nusing the field names of the case class as key names in a JSON object:\nimport io.circe.generic.auto._\nUser(\"Alice\").asJson\nEquipped with an Encoder and .asJson, we can send JSON in requests\nand responses for our case classes:\nOk(Hello(\"Alice\").asJson).unsafeRunSync()\nRequest[IO](Method.POST, uri\"/hello\")\n  .withEntity(User(\"Bob\").asJson)\nIf within some route we serve json only, we can use:\n{\nimport org.http4s.circe.CirceEntityEncoder._\n}\nThus there's no more need in calling asJson on result.\nHowever, it may introduce ambiguity errors when we also build\nsome json by hand within the same scope."},{"fileName":"json.md","title":"Receiving Raw JSON","anchor":"receiving-raw-json","body":"Just as we needed an EntityEncoder[JSON] to send JSON from a server\nor client, we need an EntityDecoder[JSON] to receive it.\nThe org.http4s.circe._ package provides an implicit\nEntityDecoder[Json].  This makes it very easy to decode a request or\nresponse body to JSON using the as syntax:\nOk(\"\"\"{\"name\":\"Alice\"}\"\"\").flatMap(_.as[Json]).unsafeRunSync()\nRequest[IO](Method.POST, uri\"/hello\")\n  .withEntity(\"\"\"{\"name\":\"Bob\"}\"\"\")\n  .as[Json].unsafeRunSync()\nLike sending raw JSON, this is useful to a point, but we typically\nwant to get to a typed model as quickly as we can."},{"fileName":"json.md","title":"Decoding JSON to a case class","anchor":"decoding-json-to-a-case-class","body":"To get from an HTTP entity to Json, we use an EntityDecoder[Json].\nTo get from Json to any type A, we need an io.circe.Decoder[A].\nhttp4s-circe provides the jsonOf function to make the connection all\nthe way from HTTP to your type A.  Specifically, jsonOf[A] takes\nan implicit Decoder[A] and makes a EntityDecoder[A]:\nimplicit val userDecoder = jsonOf[IO, User]\nOk(\"\"\"{\"name\":\"Alice\"}\"\"\").flatMap(_.as[User]).unsafeRunSync()\n\nRequest[IO](Method.POST, uri\"/hello\")\n  .withEntity(\"\"\"{\"name\":\"Bob\"}\"\"\")\n  .as[User].unsafeRunSync()\nIf we are always decoding from JSON to a typed model, we can use\nthe following import:\nimport org.http4s.circe.CirceEntityDecoder._\nThis creates an EntityDecoder[A] for every A that has a Decoder instance.\nHowever, be cautious when using this. Having this implicit\nin scope does mean that we would always try to decode HTTP entities\nfrom JSON (even if it is XML or plain text, for instance).\nFor more convenience there is import combining both encoding\nand decoding derivation:\nimport org.http4s.circe.CirceEntityCodec._"},{"fileName":"json.md","title":"A Hello World Service","anchor":"a-hello-world-service","body":"Our hello world service will parse a User from a request and offer a\nproper greeting.\nimport cats.effect.unsafe.implicits.global\nimport cats.effect._\n\nimport com.comcast.ip4s._\n\nimport io.circe.generic.auto._\nimport io.circe.syntax._\n\nimport org.http4s._\nimport org.http4s.circe._\nimport org.http4s.dsl.io._\nimport org.http4s.ember.server._\nimport org.http4s.implicits._\n\nimport scala.concurrent.duration._\n\ncase class User(name: String)\ncase class Hello(greeting: String)\n\nimplicit val decoder = jsonOf[IO, User]\n\nval jsonApp = HttpRoutes.of[IO] {\n  case req @ POST -> Root / \"hello\" =>\n    for {\n\t  // Decode a User request\n\t  user <- req.as[User]\n\t  // Encode a hello response\n\t  resp <- Ok(Hello(user.name).asJson)\n    } yield (resp)\n}.orNotFound\n\n\nval server = EmberServerBuilder\n  .default[IO]\n  .withHost(ipv4\"0.0.0.0\")\n  .withPort(port\"8080\")\n  .withHttpApp(jsonApp)\n  .build\nWe start a server resource in the background.\nval shutdown = server.allocated.unsafeRunSync()._2"},{"fileName":"json.md","title":"Putting it all together","anchor":"putting-it-all-together","body":""},{"fileName":"json.md","title":"A Hello World Client","anchor":"a-hello-world-client","body":"Now let's make a client for the service above:\nimport org.http4s.ember.client._\nimport cats.effect.IO\nimport io.circe.generic.auto._\n\ndef helloClient(name: String): IO[Hello] = {\n  // Encode a User request  \n  val req = Request[IO](Method.POST, uri\"http://localhost:8080/hello\")\n    .withEntity(User(name).asJson)\n  // Create a client\n  // Note: this client is used exactly once, and discarded\n  // Ideally you should .build.use it once, and share it for multiple requests\n  EmberClientBuilder.default[IO].build.use { httpClient =>\n    // Decode a Hello response\n    httpClient.expect(req)(jsonOf[IO, Hello])\n  }\n}\nFinally, we post User(\"Alice\") to our Hello service and expect\nHello(\"Alice\") back:\nhelloClient(\"Alice\").unsafeRunSync()\nFinally, shut down our example server.\nshutdown.unsafeRunSync()"},{"fileName":"testing.md","title":"testing","anchor":null,"body":"Testing\nThis document implements a simple org.http4s.HttpRoutes and then\nwalks through the results (i.e. org.http4s.Response) of applying inputs (i.e. org.http4s.Request) to it.\nAfter reading this doc, the reader should feel comfortable writing a unit test using his/her favorite Scala testing library.\nNow, let's define an org.http4s.HttpRoutes.\nimport cats.syntax.all._\nimport io.circe._\nimport io.circe.syntax._\nimport io.circe.generic.semiauto._\nimport cats.effect._\nimport org.http4s._\nimport org.http4s.circe._\nimport org.http4s.dsl.io._\nimport org.http4s.implicits._\nIf you're in a REPL, we also need a runtime:\nimport cats.effect.unsafe.IORuntime\nimplicit val runtime: IORuntime = cats.effect.unsafe.IORuntime.global\ncase class User(name: String, age: Int)\nimplicit val UserEncoder: Encoder[User] = deriveEncoder[User]\n\ntrait UserRepo[F[_]] {\n  def find(userId: String): F[Option[User]]\n}\n\ndef httpRoutes[F[_]](repo: UserRepo[F])(\n      implicit F: Async[F]\n): HttpRoutes[F] = HttpRoutes.of[F] {\n  case GET -> Root / \"user\" / id =>\n    repo.find(id).map {\n      case Some(user) => Response(status = Status.Ok).withEntity(user.asJson)\n      case None       => Response(status = Status.NotFound)\n    }\n}\nFor testing, let's define a check function:\n// Return true if match succeeds; otherwise false\ndef check[A](actual:        IO[Response[IO]],\n            expectedStatus: Status,\n            expectedBody:   Option[A])(\n    implicit ev: EntityDecoder[IO, A]\n): Boolean =  {\n   val actualResp         = actual.unsafeRunSync()\n   val statusCheck        = actualResp.status == expectedStatus\n   val bodyCheck          = expectedBody.fold[Boolean](\n       // Verify Response's body is empty.\n       actualResp.body.compile.toVector.unsafeRunSync().isEmpty)(\n       expected => actualResp.as[A].unsafeRunSync() == expected\n   )\n   statusCheck && bodyCheck\n}\nLet's define service by passing a UserRepo that returns Ok(user).\nval success: UserRepo[IO] = new UserRepo[IO] {\n  def find(id: String): IO[Option[User]] = IO.pure(Some(User(\"johndoe\", 42)))\n}\n\nval response: IO[Response[IO]] = httpRoutes[IO](success).orNotFound.run(\n  Request(method = Method.GET, uri = uri\"/user/not-used\" )\n)\nval expectedJson = Json.obj(\n      \"name\" := \"johndoe\",\n      \"age\" := 42\n)\n\ncheck[Json](response, Status.Ok, Some(expectedJson))\nNext, let's define a service with a userRepo that returns None to any input.\nval foundNone: UserRepo[IO] = new UserRepo[IO] {\n  def find(id: String): IO[Option[User]] = IO.pure(None)\n}\n\nval respFoundNone: IO[Response[IO]] = httpRoutes[IO](foundNone).orNotFound.run(\n  Request(method = Method.GET, uri = uri\"/user/not-used\" )\n)\ncheck[Json](respFoundNone, Status.NotFound, None)\nFinally, let's pass a Request which our service does not handle.\nval doesNotMatter: UserRepo[IO] = new UserRepo[IO] {\n  def find(id: String): IO[Option[User]] =\n    IO.raiseError(new RuntimeException(\"Should not get called!\"))\n}\n\nval respNotFound: IO[Response[IO]] = httpRoutes[IO](doesNotMatter).orNotFound.run(\n  Request(method = Method.GET, uri = uri\"/not-a-matching-path\" )\n)\ncheck[String](respNotFound, Status.NotFound, Some(\"Not found\"))"},{"fileName":"testing.md","title":"Using client","anchor":"using-client","body":"Having HttpApp you can build a client for testing purposes. Following the example above we could define our HttpApp like this:\nval httpApp: HttpApp[IO] = httpRoutes[IO](success).orNotFound\nFrom this, we can obtain the Client instance using Client.fromHttpApp and then use it to test our sever/app.\nimport org.http4s.client.Client\n\nval request: Request[IO] = Request(method = Method.GET, uri = uri\"/user/not-used\")\nval client: Client[IO] = Client.fromHttpApp(httpApp)\n\nval resp: IO[Json]     = client.expect[Json](request)\nassert(resp.unsafeRunSync() == expectedJson)"},{"fileName":"testing.md","title":"Conclusion","anchor":"conclusion","body":"The above documentation demonstrated how to define an HttpRoutes[F], pass Request's, and then\ntest the expected Response.\nTo add unit tests in your chosen Scala Testing Framework, please follow the above examples."},{"fileName":"testing.md","title":"References","anchor":"references","body":"Ross Baker's NEScala 2018 PresentationKleisliOptionT"},{"fileName":"uri.md","title":"uri","anchor":null,"body":"URI Handling"},{"fileName":"uri.md","title":"Literals","anchor":"literals","body":"http4s is a bit more strict with handling URIs than e.g. the play http client.\nInstead of passing plain Strings, http4s operates on URIs. You can construct\nliteral URI with\nimport org.http4s._\nimport org.http4s.implicits._\nval uri = uri\"http://http4s.org\""},{"fileName":"uri.md","title":"URI","anchor":"uri","body":"Use the methods on the uri class.\nval docs = uri.withPath(path\"/docs/0.15\")\nval docs2 = uri / \"docs\" / \"0.15\"\nassert(docs == docs2)"},{"fileName":"uri.md","title":"URI Template","anchor":"uri-template","body":"import org.http4s.UriTemplate._\n\nval template = UriTemplate(\n  authority = Some(Uri.Authority(host = Uri.RegName(\"http4s.org\"))),\n  scheme = Some(Uri.Scheme.http),\n  path = List(PathElm(\"docs\"), PathElm(\"0.15\"))\n)\ntemplate.toUriIfPossible"},{"fileName":"uri.md","title":"Building URIs","anchor":"building-uris","body":"Naturally, that's not enough if you want dynamic URIs. There's a few different\nways to build URIs, you can either use a predefined URI and call methods on it,\nor you could use the URLTemplates.\n\n"},{"fileName":"uri.md","title":"Receiving URIs","anchor":"receiving-uris","body":"URIs come in as strings from external routes or as data. Http4s provides\nencoders/decoders for Uri in the connector packages. If you want to build your\nown, use Uri.fromString.\nFor example one for knobs:\nimplicit val configuredUri = Configured[String]\n  .flatMap(s => Configured(_ => Uri.fromString(s).toOption))"},{"fileName":"deployment.md","title":"deployment","anchor":null,"body":"Deployment"},{"fileName":"deployment.md","title":"Assembled JAR","anchor":"assembled-jar","body":"As an example of building an assembled JAR we can use SBT with the sbt-assembly plugin. Simliar approaches should exist for other build tools. Consult their documentation. For SBT we find the plugin https://github.com/sbt/sbt-assembly.\nFor a simple project we should be able to add the sbt-assembly plugin to project/plugins.sbt and then run the assembly task. We might need to use a merge strategy if some of our dependencies have conflicting artifacts. Below is a simple example, but following the documentation will give more specific configuration examples.\nin project/plugins.sbt:\naddSbtPlugin(\"com.eed3si9n\" % \"sbt-assembly\" % \"sbt-assembly-version\")\nThen as long as we have a main method in our project:\nsbt assembly\nshould build our \"fat\" assembly jar. We should see the path of the assembly from the sbt log. For example target/scala-2.13/project-assembly-0.0.1-SNAPSHOT.jar\nFinally we can execute the jar with\njava -jar /path.to/project-assembly-0.0.1-SNAPSHOT.jar\nAt this point you should see your http4s server start up. Regarding the artifact, it might be a good idea to place it inside a docker container or create a service script via a systemd unit or similar."},{"fileName":"deployment.md","title":"Install GraalVM and Native Image plugin","anchor":"install-graalvm-and-native-image-plugin","body":"The first step is to install the core GraalVM and native-image plugin. The core GraalVM release might be thought of as a replacement for the JVM. The native-image plugin is required to create the binary. The community edition builds are free.\nAfter installing the core GraalVM you should be able to use it as a JDK. For example you might set JAVA_HOME to point to your Graal version. Otherwise, your build platform might allow you to select the Java library to build against Graal.\nexport JAVA_HOME=/path/to/graalVM\nthen\njava --version\nshould return something like\nopenjdk 11.0.6 2020-01-14\nOpenJDK Runtime Environment GraalVM CE 20.0.0 (build 11.0.6+9-jvmci-20.0-b02)\nOpenJDK 64-Bit Server VM GraalVM CE 20.0.0 (build 11.0.6+9-jvmci-20.0-b02, mixed mode, sharing)"},{"fileName":"deployment.md","title":"Graal Native Image","anchor":"graal-native-image","body":"We provide an outline for building a static native image below. Furthermore the http4s giter8 template can be used to build a native image in conjunction with this guide.\nWhy would we create such an image? Some advantages might be faster startup times or less memory usage than the JVM.\n"},{"fileName":"deployment.md","title":"(Optional) Get or build a muslC bundle required to build a static image.","anchor":"optional-get-or-build-a-muslc-bundle-required-to-build-a-static-image","body":"Note: Static images aren't supported in MacOS or Windows . If building for those platforms skip this step\nTo create a truly static native image we need to use muslC . Instructions and an example bundle are provided here. For the sake of our example, we can download the resulting bundle for our build. We will need to use the path to the unpacked bundle as an argument to build the image.\nwget https://github.com/gradinac/musl-bundle-example/releases/download/v1.0/musl.tar.gz -O - | tar -xz"},{"fileName":"deployment.md","title":"Build an assembled jar using GraalVM","anchor":"build-an-assembled-jar-using-graalvm","body":"After installing the above dependencies you should build an assembled JAR. We can again use sbt assembly or your favorite build tool / plugin to create the assembled jar. The important thing is that we should be using the GraalVM version of Java to do so."},{"fileName":"deployment.md","title":"Create the native image with the assembled JAR","anchor":"create-the-native-image-with-the-assembled-jar","body":"After we have built the assembled JAR containing all our Java dependencies, we use that JAR to build our native image. In the command below we need to replace the muslC and assembly jar paths with the appropriate locations.\nNote: Mac and Windows platforms do not support build static images. Remove --static and -H:UseMuslC=\"/path.to/muslC\" when building for those platforms.\nnative-image --static -H:+ReportExceptionStackTraces -H:UseMuslC=\"/path.to/muslC\" --allow-incomplete-classpath --no-fallback --initialize-at-build-time --enable-http --enable-https --enable-all-security-services --verbose -jar \"./path.to.assembly.jar\" projectBinaryImage\nA breakout for the command parameters (image generation options) :\n-H:UseMuslC to fix DNS and related segfaults and build a true static image that doesn't depend on linked libraries.\n--initialize-at-build-time again is related to building the static image. Again we lose performance if we instead do this at runtime.\n--enable-http, --enable-https should correspond to related protocols\n--enable-all-security-services will likely be required to make or receive https requests.\nAdditional image generation options are found in the native image reference"},{"fileName":"deployment.md","title":"Execute the native image","anchor":"execute-the-native-image","body":"Finally we should be able to execute our output projectBinaryImage\n./projectBinaryImage\nAt this point we may want to package the binary in a docker container, integrate the image generation to a greater build process, create init scripts via systemd, etc."},{"fileName":"deployment.md","title":"Why static?","anchor":"why-static","body":"As an alternative to executing via the JVM, GraalVM's native-image allows us to execute as a native binary. For example, in Linux environments this might be known as an ELF format. There are a number of ways to generate a native image, be it dynamic or static.\nA dynamic image is less portable because it depends on shared library files on each Linux host. Then similar to creating an assembly JAR containing all our Java dependencies, when we build a static native image, we build\na more portable assembly including all the dependencies to run our binary across multiple platforms. For example we could expect a static ELF-64 binary to work across multiple linux distributions of different versions for the same architecture."},{"fileName":"deployment.md","title":"META-INF resources for reflection","anchor":"meta-inf-resources-for-reflection","body":"We need META-INF resources whenever we use reflection. Reflection isn't used in http4s, though it is used by some logging implementations. We've provided a native image example in the http4s giter8 template\n\n\n\n"},{"fileName":"deployment.md","title":"Overview","anchor":"overview","body":"You've built and tested your service. How can we deploy it into production? One approach is to create an assembled JAR containing the service with all its dependencies. We can then execute it via java -jar. Another approach would be to create a native image binary via GraalVM. We will give each of these as examples below.\n\n\n\n"},{"fileName":"error-handling.md","title":"error-handling","anchor":null,"body":"Error Handling\nA MessageFailure indicates an error handling an HTTP message.  These\ninclude:\nParsingFailure: indicative of a malformed HTTP message in the\nrequest line or headers.MalformedMessageBodyFailure: indicative of a message that has a\nsyntactic error in its body.  For example, trying to decode {\n\"broken:\" as JSON will result in a MalforedMessageBodyFailure.InvalidMessageBodyFailure: indicative of a message that is\nsyntactically correct, but semantically incorrect.  A well-formed\nJSON request that is missing expected fields may generate this\nfailure.MediaTypeMissing: indicates that the message had no media type,\nand the server wasn't willing to infer it.MediaTypeMismatch: indicates that the server received a media\ntype that it wasn't prepared to handle."},{"fileName":"error-handling.md","title":"Logging","anchor":"logging","body":"If a MessageFailure is not handled by your HTTP service, it reaches\nthe backend in the form of a failed task, where it is transformed into\nan HTTP response.  To guard against XSS attacks, care is taken in each\nof these renderings to not reflect information back from the request.\nDiagnostic information about syntax errors or missing fields,\nincluding a full stack trace, is logged to the\norg.http4s.server.message-failures category at DEBUG level."},{"fileName":"error-handling.md","title":"Customizing Error Handling","anchor":"customizing-error-handling","body":"TODO"},{"fileName":"server-middleware.md","title":"server-middleware","anchor":null,"body":"Server Middleware\nHttp4s includes some middleware out of the box in the org.http4s.server.middleware\npackage. Some of it is documented in its own page:\nAuthenticationCross Origin Resource Sharing (CORS)Response Compression (GZip)HSTSCSRF\nWe'll describe and provide examples for the remaining middleware, but first we set up our service:import cats.effect._\nimport cats.syntax.all._\nimport org.typelevel.ci._\nimport org.http4s._\nimport org.http4s.dsl.io._\nimport org.http4s.implicits._\nimport org.http4s.client.Client\nimport cats.effect.unsafe.IORuntime\nimport scala.concurrent.duration._\nimport cats.effect.std.Random\nimport fs2.Stream\nimport cats.effect.std.Console\n\nimplicit val runtime: IORuntime = cats.effect.unsafe.IORuntime.global\n\nobject NameQueryParamMatcher extends QueryParamDecoderMatcher[String](\"name\")\n\nval service = HttpRoutes.of[IO] {\n  case GET -> Root / \"bad\" => BadRequest()\n  case GET -> Root / \"ok\" => Ok()\n  case r @ POST -> Root / \"post\" => r.as[Unit] >> Ok()\n  case GET -> Root / \"b\" / \"c\" => Ok()\n  case POST -> Root / \"queryForm\" :? NameQueryParamMatcher(name) => Ok(s\"hello $name\")\n  case GET -> Root / \"wait\" => IO.sleep(10.millis) >> Ok()\n  case GET -> Root / \"boom\" => IO.raiseError(new RuntimeException(\"boom!\"))\n  case r @ POST -> Root / \"reverse\" => r.as[String].flatMap(s => Ok(s.reverse))\n  case GET -> Root / \"forever\" => IO(\n    Response[IO](headers = Headers(\"hello\" -> \"hi\"))\n      .withEntity(Stream.constant(\"a\").covary[IO])\n  )\n  case r @ GET -> Root / \"doubleRead\" => (r.as[String], r.as[String])\n    .flatMapN((a, b) => Ok(s\"$a == $b\"))\n  case GET -> Root / \"random\" => Random.scalaUtilRandom[IO]\n    .flatMap(_.nextInt)\n    .flatMap(random => Ok(random.toString))\n}\n\nval okRequest = Request[IO](Method.GET, uri\"/ok\")\nval badRequest = Request[IO](Method.GET, uri\"/bad\")\nval postRequest = Request[IO](Method.POST, uri\"/post\")\nval waitRequest = Request[IO](Method.GET, uri\"/wait\")\nval boomRequest = Request[IO](Method.GET, uri\"/boom\")\nval reverseRequest = Request[IO](Method.POST, uri\"/reverse\")\nval client = Client.fromHttpApp(service.orNotFound)\nAlso note that these examples might use non-idiomatic constructs like unsafeRunSync for\nconciseness.\n// we define our own Console[IO] to sidestep some mdoc issues: https://github.com/scalameta/mdoc/issues/517\nimport cats.Show\nimplicit val mdocConsoleIO: Console[IO] = new Console[IO] {\n  val mdocConsoleOut = scala.Console.out\n  def println[A](a: A)(implicit s: Show[A] = Show.fromToString[A]): IO[Unit] = {\n    val str = s.show(a)\n    IO.blocking(mdocConsoleOut.println(str)) \n  }\n\n  def print[A](a: A)(implicit S: Show[A] = Show.fromToString[A]): IO[Unit] = IO.unit\n  def error[A](a: A)(implicit S: Show[A] = Show.fromToString[A]): IO[Unit] = IO.unit\n  def errorln[A](a: A)(implicit S: Show[A] = Show.fromToString[A]): IO[Unit] = IO.unit\n  def readLineWithCharset(charset: java.nio.charset.Charset): IO[String] = IO.pure(\"\")\n}\n"},{"fileName":"server-middleware.md","title":"Caching","anchor":"caching","body":"This middleware adds response headers so that clients know how to cache a response. It performs no server-side caching.\nBelow is one example of usage, see Caching for more methods.\nimport org.http4s.server.middleware.Caching\n\nval cacheService = Caching.cache(\n  3.hours,\n  isPublic = Left(CacheDirective.public),\n  methodToSetOn = _ == Method.GET,\n  statusToSetOn = _.isSuccess,\n  service\n).orNotFound\n\nval cacheClient = Client.fromHttpApp(cacheService)\ncacheClient.run(okRequest).use(_.headers.pure[IO]).unsafeRunSync()\ncacheClient.run(badRequest).use(_.headers.pure[IO]).unsafeRunSync()\ncacheClient.run(postRequest).use(_.headers.pure[IO]).unsafeRunSync()"},{"fileName":"server-middleware.md","title":"Date","anchor":"date","body":"Adds the current date to the response.\nimport org.http4s.server.middleware.Date\n\nval dateService = Date.httpRoutes(service).orNotFound\nval dateClient = Client.fromHttpApp(dateService)\ndateClient.run(okRequest).use(_.headers.pure[IO]).unsafeRunSync()"},{"fileName":"server-middleware.md","title":"HeaderEcho","anchor":"headerecho","body":"Adds headers included in the request to the response.\nimport org.http4s.server.middleware.HeaderEcho\n\nval echoService = HeaderEcho.httpRoutes(echoHeadersWhen = _ => true)(service).orNotFound\nval echoClient = Client.fromHttpApp(echoService)\nechoClient.run(okRequest.putHeaders(\"Hello\" -> \"hi\")).use(_.headers.pure[IO]).unsafeRunSync()"},{"fileName":"server-middleware.md","title":"ResponseTiming","anchor":"responsetiming","body":"Sets response header with the request duration.\nimport org.http4s.server.middleware.ResponseTiming\n\nval timingService = ResponseTiming(service.orNotFound)\nval timingClient = Client.fromHttpApp(timingService)\ntimingClient.run(okRequest).use(_.headers.pure[IO]).unsafeRunSync()"},{"fileName":"server-middleware.md","title":"RequestId","anchor":"requestid","body":"Use the RequestId middleware to automatically generate a X-Request-ID header for a request,\nif one wasn't supplied. Adds a X-Request-ID header to the response with the id generated\nor supplied as part of the request.\nThis heroku guide gives a brief explanation\nas to why this header is useful.\nimport org.http4s.server.middleware.RequestId\n\nval requestIdService = RequestId.httpRoutes(HttpRoutes.of[IO] {\n  case req =>\n    val reqId = req.headers.get(ci\"X-Request-ID\").fold(\"null\")(_.head.value)\n    // use request id to correlate logs with the request\n    Console[IO].println(s\"request received, cid=$reqId\") *> Ok()\n})\n\nval requestIdClient = Client.fromHttpApp(requestIdService.orNotFound)\nNote: req.attributes.lookup(RequestId.requestIdAttrKey) can also be used to lookup the request id\nextracted from the header, or the generated request id.requestIdClient.run(okRequest).use(resp =>\n  (resp.headers, resp.attributes.lookup(RequestId.requestIdAttrKey)).pure[IO]\n).unsafeRunSync()"},{"fileName":"server-middleware.md","title":"StaticHeaders","anchor":"staticheaders","body":"Adds static headers to the response.\nimport org.http4s.server.middleware.StaticHeaders\n\nval staticHeadersService = StaticHeaders(Headers(\"X-Hello\" -> \"hi\"))(service).orNotFound\nval staticHeaderClient = Client.fromHttpApp(staticHeadersService)\nstaticHeaderClient.run(okRequest).use(_.headers.pure[IO]).unsafeRunSync()"},{"fileName":"server-middleware.md","title":"Headers","anchor":"headers","body":"\n\n\n\n\n"},{"fileName":"server-middleware.md","title":"AutoSlash","anchor":"autoslash","body":"Removes a trailing slash from the requested url so that requests with trailing slash map to the route without.\nimport org.http4s.server.middleware.AutoSlash\n\nval autoSlashService = AutoSlash(service).orNotFound\nval autoSlashClient = Client.fromHttpApp(autoSlashService)\nval okWithSlash = Request[IO](Method.GET, uri\"/ok/\")\n// without the middleware the request with trailing slash fails\nclient.status(okRequest).unsafeRunSync()\nclient.status(okWithSlash).unsafeRunSync()\n\n// with the middleware both work\nautoSlashClient.status(okRequest).unsafeRunSync()\nautoSlashClient.status(okWithSlash).unsafeRunSync()"},{"fileName":"server-middleware.md","title":"DefaultHead","anchor":"defaulthead","body":"Provides a naive implementation of a HEAD request for any GET routes. The response has the same headers\nbut no body. An attempt is made to interrupt the process of generating the body.\nimport org.http4s.server.middleware.DefaultHead\n\nval headService = DefaultHead(service).orNotFound\nval headClient = Client.fromHttpApp(headService)\n/forever has an infinite body but the HEAD request terminates and includes the headers:headClient.status(Request[IO](Method.HEAD, uri\"/forever\")).unsafeRunSync()\nheadClient.run(Request[IO](Method.HEAD, uri\"/forever\")).use(_.headers.pure[IO]).unsafeRunSync()"},{"fileName":"server-middleware.md","title":"HttpMethodOverrider","anchor":"httpmethodoverrider","body":"Allows a client to \"disguise\" the http verb of a request by indicating the desired verb somewhere else in the request.\nimport org.http4s.server.middleware.HttpMethodOverrider\nimport org.http4s.server.middleware.HttpMethodOverrider.{HttpMethodOverriderConfig, QueryOverrideStrategy}\n\nval overrideService = HttpMethodOverrider(\n  service,\n  HttpMethodOverriderConfig(\n    QueryOverrideStrategy(paramName = \"realMethod\"),\n    Set(Method.GET)\n  )\n).orNotFound\nval overrideClient = Client.fromHttpApp(overrideService)\nval overrideRequest = Request[IO](Method.GET, uri\"/post?realMethod=POST\")\nclient.status(overrideRequest).unsafeRunSync()\noverrideClient.status(overrideRequest).unsafeRunSync()"},{"fileName":"server-middleware.md","title":"HttpsRedirect","anchor":"httpsredirect","body":"Redirects requests to https when the X-Forwarded-Proto header is http. This\nheader is usually provided by a load-balancer to indicate which protocol the client used.\nimport org.http4s.server.middleware.HttpsRedirect\n\nval httpsRedirectService = HttpsRedirect(service).orNotFound\nval httpsRedirectClient = Client.fromHttpApp(httpsRedirectService)\nval httpRequest = okRequest\n  .putHeaders(\"Host\" -> \"example.com\", \"X-Forwarded-Proto\" -> \"http\")\nhttpsRedirectClient.run(httpRequest).use(r => (r.headers, r.status).pure[IO]).unsafeRunSync()"},{"fileName":"server-middleware.md","title":"TranslateUri","anchor":"translateuri","body":"Removes a prefix from the path of the requested url.\nimport org.http4s.server.middleware.TranslateUri\n\nval translateService = TranslateUri(prefix = \"a\")(service).orNotFound\nval translateRequest = Request[IO](Method.GET, uri\"/a/b/c\")\nval translateClient = Client.fromHttpApp(translateService)\nThe following is successful even though /b/c is defined, and not /a/b/c:translateClient.status(translateRequest).unsafeRunSync()"},{"fileName":"server-middleware.md","title":"UrlFormLifter","anchor":"urlformlifter","body":"Transform x-www-form-urlencoded parameters into query parameters.\nimport org.http4s.server.middleware.UrlFormLifter\nimport org.http4s.UrlForm\n\nval urlFormService = UrlFormLifter.httpApp(service.orNotFound)\nval urlFormClient = Client.fromHttpApp(urlFormService)\n\nval formRequest = Request[IO](Method.POST, uri\"/queryForm\")\n  .withEntity(UrlForm.single(\"name\", \"John\"))\nEven though the /queryForm route takes query parameters, the form request works:urlFormClient.expect[String](formRequest).unsafeRunSync()"},{"fileName":"server-middleware.md","title":"Request rewriting","anchor":"request-rewriting","body":"\n\n\n\n\n"},{"fileName":"server-middleware.md","title":"ConcurrentRequests","anchor":"concurrentrequests","body":"React to requests being accepted and completed, could be used for metrics.\nimport org.http4s.server.middleware.ConcurrentRequests\nimport org.http4s.server.{ContextMiddleware, HttpMiddleware}\nimport org.http4s.ContextRequest\nimport cats.data.Kleisli\n\n// a utility that drops the context from the request, since our service expects\n// a plain request\ndef dropContext[A](middleware: ContextMiddleware[IO, A]): HttpMiddleware[IO] =\n  routes => middleware(Kleisli((c: ContextRequest[IO, A]) => routes(c.req)))\n\nval concurrentService =\n  ConcurrentRequests.route[IO](\n      onIncrement = total => Console[IO].println(s\"someone comes to town, total=$total\"),\n      onDecrement = total => Console[IO].println(s\"someone leaves town, total=$total\")\n  ).map((middle: ContextMiddleware[IO, Long]) =>\n    dropContext(middle)(service).orNotFound\n  )\n\nval concurrentClient = concurrentService.map(Client.fromHttpApp[IO])\nconcurrentClient.flatMap(cl =>\n  List.fill(3)(waitRequest).parTraverse(req => cl.expect[Unit](req))\n).void.unsafeRunSync()"},{"fileName":"server-middleware.md","title":"EntityLimiter","anchor":"entitylimiter","body":"Ensures the request body is under a specific length. It does so by inspecting\nthe body, not by simply checking Content-Length (which could be spoofed).\nThis could be useful for file uploads, or to prevent attacks that exploit\na service that loads the whole body into memory. Note that many EntityDecoders\nare susceptible to this form of attack: the String entity decoder\nwill read the complete value into memory, while a json entity decoder might build\nthe full AST before attempting to decode. For this reason it's advisable to\napply this middleware unless something else, like a reverse proxy, is\napplying this limit.\nimport org.http4s.server.middleware.EntityLimiter\n\nval limiterService = EntityLimiter.httpApp(service.orNotFound, limit = 16)\nval limiterClient = Client.fromHttpApp(limiterService)\nval smallRequest = postRequest.withEntity(\"*\" * 15)\nval bigRequest = postRequest.withEntity(\"*\" * 16)\nlimiterClient.status(smallRequest).unsafeRunSync()\nlimiterClient.status(bigRequest).attempt.unsafeRunSync()"},{"fileName":"server-middleware.md","title":"MaxActiveRequests","anchor":"maxactiverequests","body":"Limit the number of active requests by rejecting requests over a certain limit.\nThis can be useful to ensure that your service remains responsive during high loads.\nimport org.http4s.server.middleware.MaxActiveRequests\n\n// creating the middleware is effectful\nval maxService = MaxActiveRequests.forHttpApp[IO](maxActive = 2)\n  .map(middleware => middleware(service.orNotFound))\n\nval maxClient = maxService.map(Client.fromHttpApp[IO])\nSome requests will fail if the limit is reached:maxClient.flatMap(cl =>\n  List.fill(5)(waitRequest).parTraverse(req => cl.status(req))\n).unsafeRunSync()"},{"fileName":"server-middleware.md","title":"Throttle","anchor":"throttle","body":"Reject requests that exceed a given rate. An in-memory implementation of a\nTokenBucket - which refills at a given rate - is provided, but other strategies\ncan be used.\nLike MaxActiveRequest this can be used prevent a service from being affect\nby high load.\nimport org.http4s.server.middleware.Throttle\n\n// creating the middleware is effectful because of the default token bucket\nval throttleService = Throttle.httpApp[IO](\n  amount = 1,\n  per = 10.milliseconds\n)(service.orNotFound)\n\nval throttleClient = throttleService.map(Client.fromHttpApp[IO])\nWe'll submit request every 5 ms and refill a token every 10 ms:throttleClient.flatMap(cl =>\n  List.fill(5)(okRequest).traverse(req => IO.sleep(5.millis) >> cl.status(req))\n).unsafeRunSync()"},{"fileName":"server-middleware.md","title":"Timeout","anchor":"timeout","body":"Limits how long the underlying service takes to respond. The service is\ncancelled, if there are uncancelable effects they are completed and only\nthen is the response returned.\nimport org.http4s.server.middleware.Timeout\n\nval timeoutService = Timeout.httpApp[IO](timeout = 5.milliseconds)(service.orNotFound)\nval timeoutClient = Client.fromHttpApp(timeoutService)\n/wait takes 10 ms to finish so it's cancelled:timeoutClient.status(waitRequest).timed.unsafeRunSync()"},{"fileName":"server-middleware.md","title":"Scaling and resource management","anchor":"scaling-and-resource-management","body":"\n\n\n\n"},{"fileName":"server-middleware.md","title":"ErrorAction","anchor":"erroraction","body":"Triggers an action if an error occurs while processing the request. Applies\nto the error channel (like IO.raiseError, or MonadThrow[F].raiseError)\nnot http responses that indicate errors (like BadRequest).\nCould be used for logging and monitoring.\nimport org.http4s.server.middleware.ErrorAction\n\nval errorActionService = ErrorAction.httpRoutes[IO](\n  service,\n  (req, thr) => Console[IO].println(\"Oops: \" ++ thr.getMessage)\n).orNotFound\n\nval errorActionClient = Client.fromHttpApp(errorActionService)\nerrorActionClient.expect[Unit](boomRequest).attempt.unsafeRunSync()"},{"fileName":"server-middleware.md","title":"ErrorHandling","anchor":"errorhandling","body":"Interprets error conditions into an http response. This will interact with other\nmiddleware that handles exceptions, like ErrorAction.\nDifferent backends might handle exceptions differently, ErrorAction prevents\nexceptions from reaching the backend and thus makes the service more backend-agnostic.\nimport org.http4s.server.middleware.ErrorHandling\n\nval errorHandlingService = ErrorHandling.httpRoutes[IO](service).orNotFound\nval errorHandlingClient = Client.fromHttpApp(errorHandlingService)\nFor the first request (the service without ErrorHandling) we have to .attempt\nto get a value that is renderable in this document, for the second request we get a response.client.status(boomRequest).attempt.unsafeRunSync()\nerrorHandlingClient.status(boomRequest).unsafeRunSync()"},{"fileName":"server-middleware.md","title":"Metrics","anchor":"metrics","body":"Middleware to record service metrics. Requires an implementation of MetricsOps to receive metrics\ndata. Also provided are implementations for Dropwizard\nand Prometheus metrics.\nimport org.http4s.server.middleware.Metrics\nimport org.http4s.metrics.{MetricsOps, TerminationType}\n\nval metricsOps = new MetricsOps[IO] {\n  def increaseActiveRequests(classifier: Option[String]): IO[Unit] =\n    Console[IO].println(\"increaseActiveRequests\")\n\n  def decreaseActiveRequests(classifier: Option[String]): IO[Unit] = IO.unit\n  def recordHeadersTime(method: Method, elapsed: Long, classifier: Option[String]): IO[Unit] =\n    IO.unit\n  def recordTotalTime(\n    method: Method,\n    status: Status,\n    elapsed: Long,\n    classifier: Option[String]\n  ): IO[Unit] = IO.unit\n\n  def recordAbnormalTermination(\n    elapsed: Long,\n    terminationType: TerminationType,\n    classifier: Option[String]\n  ): IO[Unit] = Console[IO].println(s\"abnormalTermination - $terminationType\")\n}\n\nval metricsService = Metrics[IO](metricsOps)(service).orNotFound\nval metricsClient = Client.fromHttpApp(metricsService)\nmetricsClient.expect[Unit](boomRequest).attempt.void.unsafeRunSync()\nmetricsClient.expect[Unit](okRequest).unsafeRunSync()"},{"fileName":"server-middleware.md","title":"RequestLogger, ResponseLogger, Logger","anchor":"requestlogger-responselogger-logger","body":"Log requests and responses. ResponseLogger logs the responses, RequestLogger\nlogs the request, Logger logs both.\nimport org.http4s.server.middleware.Logger\n\nval loggerService = Logger.httpRoutes[IO](\n  logHeaders = false,\n  logBody = true,\n  redactHeadersWhen = _ => false,\n  logAction = Some((msg: String) => Console[IO].println(msg))\n)(service).orNotFound\n\nval loggerClient = Client.fromHttpApp(loggerService)\nloggerClient.expect[Unit](reverseRequest.withEntity(\"mood\")).unsafeRunSync()"},{"fileName":"server-middleware.md","title":"Error handling and Logging","anchor":"error-handling-and-logging","body":"\n\n\n"},{"fileName":"server-middleware.md","title":"BodyCache","anchor":"bodycache","body":"Consumes and caches a request body so that it can be reused later.\nUsually reading the body twice is unsafe, this middleware ensures the body is always the same,\nat the cost of keeping it in memory.\nIn this example we use a request body that always produces a different value once read:import org.http4s.server.middleware.BodyCache\n\nval bodyCacheService = BodyCache.httpRoutes(service).orNotFound\n\nval randomRequest = Request[IO](Method.GET, uri\"/doubleRead\")\n  .withEntity(\n    Stream.eval(\n      Random.scalaUtilRandom[IO].flatMap(_.nextInt).map(random => random.toString)\n    )\n  )\n\nval bodyCacheClient = Client.fromHttpApp(bodyCacheService)\n/doubleRead reads the body twice, when using the middleware we see that both read values the same:client.expect[String](randomRequest).unsafeRunSync()\nbodyCacheClient.expect[String](randomRequest).unsafeRunSync()"},{"fileName":"server-middleware.md","title":"BracketRequestResponse","anchor":"bracketrequestresponse","body":"Brackets the handling of the request ensuring an action happens before the service handles\nthe request (acquire) and another after the response is complete (release),\nthe result of acquire is threaded to the underlying service.\nIt's used to implement MaxActiveRequests and ConcurrentRequests.\nSee BracketRequestResponse for more constructors.\nimport org.http4s.server.middleware.BracketRequestResponse\nimport org.http4s.ContextRoutes\nimport cats.effect.Ref\n\nval ref = Ref[IO].of(0).unsafeRunSync()\n\nval bracketMiddleware = BracketRequestResponse.bracketRequestResponseRoutes[IO, Int](\n  acquire = ref.updateAndGet(_ + 1))(\n  release = _ => ref.update(_ - 1)\n)\n\nval bracketService = bracketMiddleware(\n  ContextRoutes.of[Int, IO] {\n    case GET -> Root / \"ok\" as n => Ok(s\"$n\")\n  }\n).orNotFound\n\nval bracketClient = Client.fromHttpApp(bracketService)\nbracketClient.expect[String](okRequest).unsafeRunSync()\nref.get.unsafeRunSync()"},{"fileName":"server-middleware.md","title":"ChunkAggregator","anchor":"chunkaggregator","body":"Consumes and caches a response body so that it can be reused later.\nUsually reading the body twice is unsafe, this middleware ensures the body is always the same,\nat the cost of keeping it in memory.\nSimilarly to BodyRequest in this example we use a response body that always produces a different value:import org.http4s.server.middleware.ChunkAggregator\n\nval chunkAggregatorService = ChunkAggregator.httpRoutes(service).orNotFound\nval chunkAggregatorClient = Client.fromHttpApp(chunkAggregatorService)\nchunkAggregatorClient.run(Request[IO](Method.GET, uri\"/random\"))\n  .use(r => (r.as[String], r.as[String]).mapN((a, b) => s\"$a == $b\"))\n  .unsafeRunSync()"},{"fileName":"server-middleware.md","title":"Jsonp","anchor":"jsonp","body":"Jsonp is a javascript technique to load json data without using XMLHttpRequest,\nwhich bypasses the same-origin security policy implemented in browsers.\nJsonp usage is discouraged and can often be replaced with correct CORS configuration.\nimport org.http4s.server.middleware.Jsonp\n\nval jsonRoutes = HttpRoutes.of[IO] {\n  case GET -> Root / \"json\" => Ok(\"\"\"{\"a\": 1}\"\"\")\n}\n\nval jsonService = Jsonp(callbackParam = \"handleJson\")(jsonRoutes).orNotFound\nval jsonClient = Client.fromHttpApp(jsonService)\nval jsonRequest = Request[IO](Method.GET, uri\"/json\")\n\njsonClient.expect[String](jsonRequest).unsafeRunSync()"},{"fileName":"server-middleware.md","title":"ContextMiddleware","anchor":"contextmiddleware","body":"This middleware allows extracting context from a request and propagating it down to the routes.\nimport org.http4s.server.ContextMiddleware\nimport org.http4s.ContextRoutes\nimport cats.data.{Kleisli, OptionT}\n\n// create a custom header\ncase class UserId(raw: String)\nimplicit val userIdHeader: Header[UserId, Header.Single] =\n  Header.createRendered(ci\"X-UserId\", _.raw, s => Right(UserId(s)))\n\n// middleware to read the user id from the request\nval middleware = ContextMiddleware(\n  Kleisli((r: Request[IO]) => OptionT.fromOption[IO](r.headers.get[UserId]))\n)\n\n// routes that expect a user id as context\nval ctxRoutes = ContextRoutes.of[UserId, IO] {\n  case GET -> Root / \"ok\" as userId => Ok(s\"hello ${userId.raw}\")\n}\n\nval contextService = middleware(ctxRoutes).orNotFound\nval contextClient = Client.fromHttpApp(contextService)\nval contextRequest = Request[IO](Method.GET, uri\"/ok\").putHeaders(UserId(\"Jack\"))\ncontextClient.expect[String](contextRequest).unsafeRunSync()"},{"fileName":"server-middleware.md","title":"Advanced","anchor":"advanced","body":"\n\n\n\n"},{"fileName":"methods.md","title":"methods","anchor":null,"body":"HTTP Methods\nFor a REST API, your service will want to support different verbs/methods.\nHttp4s has a list of all the methods you're familiar with, and a few more.\nimport cats.effect._\nimport io.circe.generic.auto._\nimport io.circe.syntax._\nimport org.http4s._, org.http4s.dsl.io._\nimport org.http4s.circe._\ncase class TweetWithId(id: Int, message: String)\ncase class Tweet(message: String)\n\ndef getTweet(tweetId: Int): IO[Option[TweetWithId]] = ???\ndef addTweet(tweet: Tweet): IO[TweetWithId] = ???\ndef updateTweet(id: Int, tweet: Tweet): IO[Option[TweetWithId]] = ???\ndef deleteTweet(id: Int): IO[Unit] = ???\n\nimplicit val tweetWithIdEncoder = jsonEncoderOf[IO, TweetWithId]\nimplicit val tweetDecoder = jsonOf[IO, Tweet]\n\nval tweetService = HttpRoutes.of[IO] {\n  case GET -> Root / \"tweets\" / IntVar(tweetId) =>\n    getTweet(tweetId)\n      .flatMap(_.fold(NotFound())(Ok(_)))\n  case req @ POST -> Root / \"tweets\" =>\n    req.as[Tweet].flatMap(addTweet).flatMap(Ok(_))\n  case req @ PUT -> Root / \"tweets\" / IntVar(tweetId) =>\n    req.as[Tweet]\n      .flatMap(updateTweet(tweetId, _))\n      .flatMap(_.fold(NotFound())(Ok(_)))\n  case HEAD -> Root / \"tweets\" / IntVar(tweetId) =>\n    getTweet(tweetId)\n      .flatMap(_.fold(NotFound())(_ => Ok()))\n  case DELETE -> Root / \"tweets\" / IntVar(tweetId) =>\n    deleteTweet(tweetId)\n      .flatMap(_ => Ok())\n}\nThere's also DefaultHead which replicates the functionality of the native\nimplementation of the HEAD route."}]